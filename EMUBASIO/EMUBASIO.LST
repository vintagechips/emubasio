    1                   ;       EMUBASIC based on GRANT's BASIC
    2                   ;       TARGET: EMUZ80
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5                   ;       START UP ROUTINE
    6                   ;       VERSION 1.0, 2022/02/15
    7                   ;       WRITTEN by TETSUYA SUZUKI
    8                   ;
    9                   ;       MEMORY ASIGN
   10 0000              ROMTOP     EQU      0000H
   11 8000              RAMTOP     EQU      8000H
   12 1000              RAMSIZ     EQU      1000H
   13 80ED              TSTACK     EQU      80EDH
   14                   ;
   15                   ;       UART REGISTER ADDRESS
   16 0000              UARTDR     EQU      00H         ; UART CONTROL REGISTOR
   17 0001              UARTCR     EQU      01H         ; UART DATA REGISTOR
   18                   ;
   19                   ;       RESET (RST 00H)
   20 0000                         ORG      ROMTOP
   21 0000 F3                      DI
   22 0001 31ED80                  LD       SP,TSTACK
   23 0004 C33C00                  JP       SINIT
   24                   ;
   25                   ;       PUT 1CHAR (RST 08H)
   26 0008                         ORG      ROMTOP+08H
   27 0008 C33100                  JP       TXA
   28                   ;
   29                   ;       GET 1CHAR (RST 10H)
   30 0010                         ORG      ROMTOP+10H
   31 0010 C31B00                  JP       RXA
   32                   ;
   33                   ;       KBHIT (RST 18H)
   34 0018                         ORG      ROMTOP+18H
   35 0018 C32C00                  JP       KBHIT
   36                   ;
   37                   ;       UART -> A
   38 001B DB01         RXA:       IN       A,(UARTCR)
   39 001D CB47                    BIT      0,A
   40 001F 28FA                    JR       Z,RXA
   41 0021 DB00                    IN       A,(UARTDR)
   42 0023 FE61                    CP       'a'
   43 0025 D8                      RET      C
   44 0026 FE7B                    CP       'z'+1
   45 0028 D0                      RET      NC
   46 0029 E6DF                    AND      0DFH
   47 002B C9                      RET
   48                   ;
   49                   ;       CHECK RECEIVE STATUS
   50 002C DB01         KBHIT:     IN       A,(UARTCR)
   51 002E CB47                    BIT      0,A
   52 0030 C9                      RET
   53                   ;
   54                   ;       A -> UART
   55 0031 F5           TXA:       PUSH     AF
   56 0032 DB01         TXAST1:    IN       A,(UARTCR)
   57 0034 CB4F                    BIT      1,A
   58 0036 28FA                    JR       Z,TXAST1
   59 0038 F1                      POP      AF
   60 0039 D300                    OUT      (UARTDR),A
   61 003B C9                      RET
   62                   ;
   63                   ;
   64                   ;       SYSTEM INITIALIZE
   65 003C              SINIT:
   66 003C C33F00                  JP       COLD
   67                   ;
   68                   ;======================================================
   69                   ; The updates to the original BASIC within this file ar
   70                   ;
   71                   ; You have permission to use this for NON COMMERCIAL US
   72                   ; If you wish to use it elsewhere, please include an ac
   73                   ;
   74                   ; http://searle.hostei.com/grant/index.html
   75                   ;
   76                   ; eMail: home.micros01@btinternet.com
   77                   ;
   78                   ; If the above don't work, please perform an Internet s
   79                   ; updated the web page hosting service.
   80                   ;
   81                   ;======================================================
   82                   ;
   83                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
   84                   ; Scanned from source published in 80-BUS NEWS from Vol
   85                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
   86                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
   87                   ; the original ROM code (checksum A934H). PA
   88                   ;
   89                   ; GENERAL EQUATES
   90                   ;
   91 0003              CTRLC      EQU      03H         ; Control "C"
   92 0007              CTRLG      EQU      07H         ; Control "G"
   93 0008              BKSP       EQU      08H         ; Back space
   94 000A              LF         EQU      0AH         ; Line feed
   95 000C              CS         EQU      0CH         ; Clear screen
   96 000D              CR         EQU      0DH         ; Carriage return
   97 000F              CTRLO      EQU      0FH         ; Control "O"
   98 0011              CTRLQ      EQU      11H         ; Control "Q"
   99 0012              CTRLR      EQU      12H         ; Control "R"
  100 0013              CTRLS      EQU      13H         ; Control "S"
  101 0015              CTRLU      EQU      15H         ; Control "U"
  102 001B              ESC        EQU      1BH         ; Escape
  103 007F              DEL        EQU      7FH         ; Delete
  104                   ;
  105                   ; BASIC WORK SPACE LOCATIONS
  106                   ;
  107 8045              WRKSPC     EQU      8045H       ; BASIC Work space
  108 8048              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
  109 804B              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
  110 804C              OTPORT     EQU      WRKSPC+7H   ; Port (p)
  111 804E              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
  112 804F              DIV1       EQU      WRKSPC+0AH  ; <- Values
  113 8053              DIV2       EQU      WRKSPC+0EH  ; <- to
  114 8057              DIV3       EQU      WRKSPC+12H  ; <- be
  115 805A              DIV4       EQU      WRKSPC+15H  ; <- inserted
  116 805C              SEED       EQU      WRKSPC+17H  ; Random number seed
  117 807F              LSTRND     EQU      WRKSPC+3AH  ; Last random number
  118 8083              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
  119 8084              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
  120 8086              NULLS      EQU      WRKSPC+41H  ; Number of nulls
  121 8087              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
  122 8088              COMMAN     EQU      WRKSPC+43H  ; Width for commas
  123 8089              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
  124 808A              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
  125 808B              LINESC     EQU      WRKSPC+46H  ; Lines counter
  126 808D              LINESN     EQU      WRKSPC+48H  ; Lines number
  127 808F              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  128 8091              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  129 8092              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  130 8093              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  131 8096              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  132 8099              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  133 809C              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  134 809F              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  135 80A1              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  136 80A3              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  137 80A6              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  138 80AB              STACK      EQU      WRKSPC+66H  ; Initial stack
  139 80F0              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  140 80F1              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  141 80F2              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  142 80F3              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  143 80F4              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  144 80F6              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  145 80F8              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  146 8104              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  147 8108              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  148 810A              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  149 810C              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  150 810E              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  151 8110              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  152 8111              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  153 8112              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  154 8113              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  155 8115              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  156 8117              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  157 8119              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  158 811B              PROGND     EQU      WRKSPC+0D6H ; End of program
  159 811D              VAREND     EQU      WRKSPC+0D8H ; End of variables
  160 811F              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  161 8121              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  162 8123              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  163 8125              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  164 8129              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  165 812C              FPEXP      EQU      FPREG+3     ; Floating point expone
  166 812D              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  167 812E              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  168 813B              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  169 813E              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  170 81A2              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  171                   ;
  172                   ; BASIC ERROR CODE VALUES
  173                   ;
  174 0000              NF         EQU      00H         ; NEXT without FOR
  175 0002              SN         EQU      02H         ; Syntax error
  176 0004              RG         EQU      04H         ; RETURN without GOSUB
  177 0006              OD         EQU      06H         ; Out of DATA
  178 0008              FC         EQU      08H         ; Function call error
  179 000A              OV         EQU      0AH         ; Overflow
  180 000C              OM         EQU      0CH         ; Out of memory
  181 000E              UL         EQU      0EH         ; Undefined line number
  182 0010              BS         EQU      10H         ; Bad subscript
  183 0012              RD         EQU      12H         ; Re-DIMensioned array
  184 0014              DZ         EQU      14H         ; Division by zero (/0)
  185 0016              ID         EQU      16H         ; Illegal direct
  186 0018              TM         EQU      18H         ; Type miss-match
  187 001A              OS         EQU      1AH         ; Out of string space
  188 001C              LS         EQU      1CH         ; String too long
  189 001E              ST         EQU      1EH         ; String formula too co
  190 0020              CN         EQU      20H         ; Can't CONTinue
  191 0022              UF         EQU      22H         ; UnDEFined FN function
  192 0024              MO         EQU      24H         ; Missing operand
  193 0026              HX         EQU      26H         ; HEX error
  194 0028              BN         EQU      28H         ; BIN error
  195                   ;
  196 003F C34500       COLD:      JP       STARTB      ; Jump for cold start
  197 0042 C3BA00       WARM:      JP       WARMST      ; Jump for warm start
  198 0045 C34C00       STARTB:    JP       CSTART      ; Jump to initialise
  199                   ;
  200 0048 FD08                    DW       DEINT       ; Get integer -32768 to
  201 004A 7310                    DW       ABPASS      ; Return integer in AB
  202                   ;
  203 004C 214580       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  204 004F F9                      LD       SP,HL       ; Set up a temporary st
  205 0050 C38E1C                  JP       INITST      ; Go to initialise
  206                   ;
  207 0053 112403       INIT:      LD       DE,INITAB   ; Initialise workspace
  208 0056 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  209 0058 214580                  LD       HL,WRKSPC   ; Into workspace RAM
  210 005B 1A           COPY:      LD       A,(DE)      ; Get source
  211 005C 77                      LD       (HL),A      ; To destination
  212 005D 23                      INC      HL          ; Next destination
  213 005E 13                      INC      DE          ; Next source
  214 005F 05                      DEC      B           ; Count bytes
  215 0060 C25B00                  JP       NZ,COPY     ; More to move
  216 0063 F9                      LD       SP,HL       ; Temporary stack
  217 0064 CD2505                  CALL     CLREG       ; Clear registers and s
  218 0067 CDF30A                  CALL     PRCRLF      ; Output CRLF
  219 006A 32EF80                  LD       (BUFFER+72+1),A ; Mark end of buffe
  220 006D 323E81                  LD       (PROGST),A  ; Initialise program ar
  221 0070 21A281       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  222 0073 23           MLOOP:     INC      HL          ; Next byte
  223 0074 7C                      LD       A,H         ; Above address FFFF ?
  224 0075 B5                      OR       L
  225 0076 CA8200                  JP       Z,SETTOP    ; Yes - 64K RAM
  226 0079 7E                      LD       A,(HL)      ; Get contents
  227 007A 47                      LD       B,A         ; Save it
  228 007B 2F                      CPL                  ; Flip all bits
  229 007C 77                      LD       (HL),A      ; Put it back
  230 007D BE                      CP       (HL)        ; RAM there if same
  231 007E 70                      LD       (HL),B      ; Restore old contents
  232 007F CA7300                  JP       Z,MLOOP     ; If RAM - test next by
  233                   ;
  234 0082 2B           SETTOP:    DEC      HL          ; Back one byte
  235 0083 11A181                  LD       DE,STLOOK-1 ; See if enough RAM
  236 0086 CDBB06                  CALL     CPDEHL      ; Compare DE with HL
  237 0089 DAC300                  JP       C,NEMEM     ; If not enough RAM
  238 008C 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  239 008F 22F480                  LD       (LSTRAM),HL ; Save last available R
  240 0092 19                      ADD      HL,DE       ; Allocate string space
  241 0093 229F80                  LD       (STRSPC),HL ; Save string space
  242 0096 CD0005                  CALL     CLRPTR      ; Clear program area
  243 0099 2A9F80                  LD       HL,(STRSPC) ; Get end of memory
  244 009C 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  245 009F 19                      ADD      HL,DE       ; Adjust HL
  246 00A0 113E81                  LD       DE,PROGST   ; Start of program text
  247 00A3 7D                      LD       A,L         ; Get LSB
  248 00A4 93                      SUB      E           ; Adjust it
  249 00A5 6F                      LD       L,A         ; Re-save
  250 00A6 7C                      LD       A,H         ; Get MSB
  251 00A7 9A                      SBC      A,D         ; Adjust it
  252 00A8 67                      LD       H,A         ; Re-save
  253 00A9 E5                      PUSH     HL          ; Save bytes free
  254 00AA 21DB00                  LD       HL,SIGNON   ; Sign-on message
  255 00AD CD9111                  CALL     PRS         ; Output string
  256 00B0 E1                      POP      HL          ; Get bytes free back
  257 00B1 CD3418                  CALL     PRNTHL      ; Output amount of free
  258 00B4 21CC00                  LD       HL,BFREE    ; " Bytes free" message
  259 00B7 CD9111                  CALL     PRS         ; Output string
  260                   ;
  261 00BA 31AB80       WARMST:    LD       SP,STACK    ; Temporary stack
  262 00BD CD2505       BRKRET:    CALL     CLREG       ; Clear registers and s
  263 00C0 C33E04                  JP       PRNTOK      ; Go to get command lin
  264                   ;
  265 00C3 211201       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  266 00C6 CD9111                  CALL     PRS         ; Print it
  267 00C9 C3C900       XXXXX:     JP       XXXXX       ; Stop
  268                   ;
  269 00CC 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  270                   ;
  271 00DB 5A3830204241 SIGNON:    DB       "Z80 BASIC Ver 4.7b",CR,LF
           534943205665 
           7220342E3762 
           0D0A         
  272 00EF 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  273 00FC 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  274                   ;
  275 0112 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  276 012A 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  277                   ;
  278                   ; FUNCTION ADDRESS TABLE
  279                   ;
  280 0144 A916         FNCTAB:    DW       SGN
  281 0146 6D17                    DW       INT
  282 0148 BF16                    DW       ABS
  283 014A 4880                    DW       USR
  284 014C 5110                    DW       FRE
  285 014E D613                    DW       INP
  286 0150 7F10                    DW       POS
  287 0152 3319                    DW       SQR
  288 0154 121A                    DW       RND
  289 0156 4E15                    DW       LOG
  290 0158 8119                    DW       EXP
  291 015A 871A                    DW       COS
  292 015C 8D1A                    DW       SIN
  293 015E EE1A                    DW       TAN
  294 0160 031B                    DW       ATN
  295 0162 2A14                    DW       PEEK
  296 0164 6E1B                    DW       DEEK
  297 0166 9680                    DW       POINT
  298 0168 0313                    DW       LEN
  299 016A 1B11                    DW       STR
  300 016C 9D13                    DW       VAL
  301 016E 1213                    DW       ASC
  302 0170 2313                    DW       CHR
  303 0172 901B                    DW       HEX
  304 0174 231C                    DW       BIN
  305 0176 3313                    DW       LEFT
  306 0178 6313                    DW       RIGHT
  307 017A 6D13                    DW       MID
  308                   ;
  309                   ; RESERVED WORD LIST
  310                   ;
  311 017C C54E44       WORDS:     DB       0C5H,"ND"
  312 017F C64F52                  DB       0C6H,"OR"
  313 0182 CE455854                DB       0CEH,"EXT"
  314 0186 C4415441                DB       0C4H,"ATA"
  315 018A C94E505554              DB       0C9H,"NPUT"
  316 018F C4494D                  DB       0C4H,"IM"
  317 0192 D2454144                DB       0D2H,"EAD"
  318 0196 CC4554                  DB       0CCH,"ET"
  319 0199 C74F544F                DB       0C7H,"OTO"
  320 019D D2554E                  DB       0D2H,"UN"
  321 01A0 C946                    DB       0C9H,"F"
  322 01A2 D24553544F52            DB       0D2H,"ESTORE"
           45           
  323 01A9 C74F535542              DB       0C7H,"OSUB"
  324 01AE D2455455524E            DB       0D2H,"ETURN"
  325 01B4 D2454D                  DB       0D2H,"EM"
  326 01B7 D3544F50                DB       0D3H,"TOP"
  327 01BB CF5554                  DB       0CFH,"UT"
  328 01BE CF4E                    DB       0CFH,"N"
  329 01C0 CE554C4C                DB       0CEH,"ULL"
  330 01C4 D7414954                DB       0D7H,"AIT"
  331 01C8 C44546                  DB       0C4H,"EF"
  332 01CB D04F4B45                DB       0D0H,"OKE"
  333 01CF C44F4B45                DB       0C4H,"OKE"
  334 01D3 D3435245454E            DB       0D3H,"CREEN"
  335 01D9 CC494E4553              DB       0CCH,"INES"
  336 01DE C34C53                  DB       0C3H,"LS"
  337 01E1 D749445448              DB       0D7H,"IDTH"
  338 01E6 CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  339 01ED D34554                  DB       0D3H,"ET"
  340 01F0 D245534554              DB       0D2H,"ESET"
  341 01F5 D052494E54              DB       0D0H,"RINT"
  342 01FA C34F4E54                DB       0C3H,"ONT"
  343 01FE CC495354                DB       0CCH,"IST"
  344 0202 C34C454152              DB       0C3H,"LEAR"
  345 0207 C34C4F4144              DB       0C3H,"LOAD"
  346 020C C353415645              DB       0C3H,"SAVE"
  347 0211 CE4557                  DB       0CEH,"EW"
  348                   ;
  349 0214 D4414228                DB       0D4H,"AB("
  350 0218 D44F                    DB       0D4H,"O"
  351 021A C64E                    DB       0C6H,"N"
  352 021C D3504328                DB       0D3H,"PC("
  353 0220 D448454E                DB       0D4H,"HEN"
  354 0224 CE4F54                  DB       0CEH,"OT"
  355 0227 D3544550                DB       0D3H,"TEP"
  356                   ;
  357 022B AB                      DB       0ABH
  358 022C AD                      DB       0ADH
  359 022D AA                      DB       0AAH
  360 022E AF                      DB       0AFH
  361 022F DE                      DB       0DEH
  362 0230 C14E44                  DB       0C1H,"ND"
  363 0233 CF52                    DB       0CFH,"R"
  364 0235 BE                      DB       0BEH
  365 0236 BD                      DB       0BDH
  366 0237 BC                      DB       0BCH
  367                   ;
  368 0238 D3474E                  DB       0D3H,"GN"
  369 023B C94E54                  DB       0C9H,"NT"
  370 023E C14253                  DB       0C1H,"BS"
  371 0241 D55352                  DB       0D5H,"SR"
  372 0244 C65245                  DB       0C6H,"RE"
  373 0247 C94E50                  DB       0C9H,"NP"
  374 024A D04F53                  DB       0D0H,"OS"
  375 024D D35152                  DB       0D3H,"QR"
  376 0250 D24E44                  DB       0D2H,"ND"
  377 0253 CC4F47                  DB       0CCH,"OG"
  378 0256 C55850                  DB       0C5H,"XP"
  379 0259 C34F53                  DB       0C3H,"OS"
  380 025C D3494E                  DB       0D3H,"IN"
  381 025F D4414E                  DB       0D4H,"AN"
  382 0262 C1544E                  DB       0C1H,"TN"
  383 0265 D045454B                DB       0D0H,"EEK"
  384 0269 C445454B                DB       0C4H,"EEK"
  385 026D D04F494E54              DB       0D0H,"OINT"
  386 0272 CC454E                  DB       0CCH,"EN"
  387 0275 D3545224                DB       0D3H,"TR$"
  388 0279 D6414C                  DB       0D6H,"AL"
  389 027C C15343                  DB       0C1H,"SC"
  390 027F C3485224                DB       0C3H,"HR$"
  391 0283 C8455824                DB       0C8H,"EX$"
  392 0287 C2494E24                DB       0C2H,"IN$"
  393 028B CC45465424              DB       0CCH,"EFT$"
  394 0290 D24947485424            DB       0D2H,"IGHT$"
  395 0296 CD494424                DB       0CDH,"ID$"
  396 029A 80                      DB       80H         ; End of list marker
  397                   ;
  398                   ; KEYWORD ADDRESS TABLE
  399                   ;
  400 029B 9508         WORDTB:    DW       PEND
  401 029D 9207                    DW       FOR
  402 029F 6D0C                    DW       NEXT
  403 02A1 E209                    DW       DATA
  404 02A3 740B                    DW       INPUT
  405 02A5 A90E                    DW       DIM
  406 02A7 A30B                    DW       READ
  407 02A9 F909                    DW       LET
  408 02AB 9F09                    DW       GOTO
  409 02AD 8209                    DW       RUN
  410 02AF 710A                    DW       IF
  411 02B1 5B08                    DW       RESTOR
  412 02B3 8E09                    DW       GOSUB
  413 02B5 BD09                    DW       RETURN
  414 02B7 E409                    DW       REM
  415 02B9 9308                    DW       STOP
  416 02BB E213                    DW       POUT
  417 02BD 530A                    DW       ON
  418 02BF D408                    DW       NULL
  419 02C1 E813                    DW       WAIT
  420 02C3 8710                    DW       DEF
  421 02C5 3114                    DW       POKE
  422 02C7 791B                    DW       DOKE
  423 02C9 E409                    DW       REM
  424 02CB 5F1B                    DW       LINES
  425 02CD 521B                    DW       CLS
  426 02CF 571B                    DW       WIDTH
  427 02D1 8B1C                    DW       MONITR
  428 02D3 9980                    DW       PSET
  429 02D5 9C80                    DW       RESET
  430 02D7 950A                    DW       PRINT
  431 02D9 C108                    DW       CONT
  432 02DB 0707                    DW       LIST
  433 02DD 3C09                    DW       CLEAR
  434 02DF E409                    DW       REM
  435 02E1 E409                    DW       REM
  436 02E3 FF04                    DW       NEW
  437                   ;
  438                   ; RESERVED WORD TOKEN VALUES
  439                   ;
  440 0080              ZEND       EQU      080H        ; END
  441 0081              ZFOR       EQU      081H        ; FOR
  442 0083              ZDATA      EQU      083H        ; DATA
  443 0088              ZGOTO      EQU      088H        ; GOTO
  444 008C              ZGOSUB     EQU      08CH        ; GOSUB
  445 008E              ZREM       EQU      08EH        ; REM
  446 009E              ZPRINT     EQU      09EH        ; PRINT
  447 00A4              ZNEW       EQU      0A4H        ; NEW
  448                   ;
  449 00A5              ZTAB       EQU      0A5H        ; TAB
  450 00A6              ZTO        EQU      0A6H        ; TO
  451 00A7              ZFN        EQU      0A7H        ; FN
  452 00A8              ZSPC       EQU      0A8H        ; SPC
  453 00A9              ZTHEN      EQU      0A9H        ; THEN
  454 00AA              ZNOT       EQU      0AAH        ; NOT
  455 00AB              ZSTEP      EQU      0ABH        ; STEP
  456                   ;
  457 00AC              ZPLUS      EQU      0ACH        ; +
  458 00AD              ZMINUS     EQU      0ADH        ; -
  459 00AE              ZTIMES     EQU      0AEH        ; *
  460 00AF              ZDIV       EQU      0AFH        ; /
  461 00B2              ZOR        EQU      0B2H        ; OR
  462 00B3              ZGTR       EQU      0B3H        ; >
  463 00B4              ZEQUAL     EQU      0B4H        ; M
  464 00B5              ZLTH       EQU      0B5H        ; <
  465 00B6              ZSGN       EQU      0B6H        ; SGN
  466 00C7              ZPOINT     EQU      0C7H        ; POINT
  467 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  468                   ;
  469                   ; ARITHMETIC PRECEDENCE TABLE
  470                   ;
  471 02E5 79           PRITAB:    DB       79H         ; Precedence value
  472 02E6 1B18                    DW       PADD        ; FPREG = <last> + FPRE
  473                   ;
  474 02E8 79                      DB       79H         ; Precedence value
  475 02E9 4F14                    DW       PSUB        ; FPREG = <last> - FPRE
  476                   ;
  477 02EB 7C                      DB       7CH         ; Precedence value
  478 02EC 8D15                    DW       MULT        ; PPREG = <last> * FPRE
  479                   ;
  480 02EE 7C                      DB       7CH         ; Precedence value
  481 02EF EE15                    DW       DIV         ; FPREG = <last> / FPRE
  482                   ;
  483 02F1 7F                      DB       7FH         ; Precedence value
  484 02F2 3C19                    DW       POWER       ; FPREG = <last> ^ FPRE
  485                   ;
  486 02F4 50                      DB       50H         ; Precedence value
  487 02F5 020E                    DW       PAND        ; FPREG = <last> AND FP
  488                   ;
  489 02F7 46                      DB       46H         ; Precedence value
  490 02F8 010E                    DW       POR         ; FPREG = <last> OR FPR
  491                   ;
  492                   ; BASIC ERROR CODE LIST
  493                   ;
  494 02FA 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  495 02FC 534E                    DB       "SN"        ; Syntax error
  496 02FE 5247                    DB       "RG"        ; RETURN without GOSUB
  497 0300 4F44                    DB       "OD"        ; Out of DATA
  498 0302 4643                    DB       "FC"        ; Illegal function call
  499 0304 4F56                    DB       "OV"        ; Overflow error
  500 0306 4F4D                    DB       "OM"        ; Out of memory
  501 0308 554C                    DB       "UL"        ; Undefined line
  502 030A 4253                    DB       "BS"        ; Bad subscript
  503 030C 4444                    DB       "DD"        ; Re-DIMensioned array
  504 030E 2F30                    DB       "/0"        ; Division by zero
  505 0310 4944                    DB       "ID"        ; Illegal direct
  506 0312 544D                    DB       "TM"        ; Type mis-match
  507 0314 4F53                    DB       "OS"        ; Out of string space
  508 0316 4C53                    DB       "LS"        ; String too long
  509 0318 5354                    DB       "ST"        ; String formula too co
  510 031A 434E                    DB       "CN"        ; Can't CONTinue
  511 031C 5546                    DB       "UF"        ; Undefined FN function
  512 031E 4D4F                    DB       "MO"        ; Missing operand
  513 0320 4858                    DB       "HX"        ; HEX error
  514 0322 424E                    DB       "BN"        ; BIN error
  515                   ;
  516                   ; INITIALISATION TABLE --------------------------------
  517                   ;
  518 0324 C3BA00       INITAB:    JP       WARMST      ; Warm start jump
  519 0327 C31209                  JP       FCERR       ; "USR (X)" jump (Set t
  520 032A D300                    OUT      (0),A       ; "OUT p,n" skeleton
  521 032C C9                      RET
  522 032D D600                    SUB      0           ; Division support rout
  523 032F 6F                      LD       L,A
  524 0330 7C                      LD       A,H
  525 0331 DE00                    SBC      A,0
  526 0333 67                      LD       H,A
  527 0334 78                      LD       A,B
  528 0335 DE00                    SBC      A,0
  529 0337 47                      LD       B,A
  530 0338 3E00                    LD       A,0
  531 033A C9                      RET
  532 033B 000000                  DB       0,0,0       ; Random number seed ta
  533 033E 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  534 0342 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  535 0346 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  536 034A 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  537 034E 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  538 0352 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  539 0356 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  540 035A D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  541 035E 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  542 0362 DB00                    IN       A,(0)       ; INP (x) skeleton
  543 0364 C9                      RET
  544 0365 01                      DB       1           ; POS (x) number (1)
  545 0366 FF                      DB       255         ; Terminal width (255 =
  546 0367 1C                      DB       28          ; Width for commas (3 c
  547 0368 00                      DB       0           ; No nulls after input 
  548 0369 00                      DB       0           ; Output enabled (^O of
  549 036A 1400                    DW       20          ; Initial lines counter
  550 036C 1400                    DW       20          ; Initial lines number
  551 036E 0000                    DW       0           ; Array load/save check
  552 0370 00                      DB       0           ; Break not by NMI
  553 0371 00                      DB       0           ; Break flag
  554 0372 C33806                  JP       TTYLIN      ; Input reflection (set
  555 0375 C30000                  JP       0000H       ; POINT reflection unus
  556 0378 C30000                  JP       0000H       ; SET reflection
  557 037B C30000                  JP       0000H       ; RESET reflection
  558 037E A281                    DW       STLOOK      ; Temp string space
  559 0380 FEFF                    DW       -2          ; Current line number (
  560 0382 3F81                    DW       PROGST+1    ; Start of program text
  561 0384              INITBE:
  562                   ;
  563                   ; END OF INITIALISATION TABLE -------------------------
  564                   ;
  565 0384 204572726F72 ERRMSG:    DB       " Error",0
           00           
  566 038B 20696E2000   INMSG:     DB       " in ",0
  567 038F              ZERBYT     EQU      $-1         ; A zero byte
  568 0390 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  569 0396 427265616B00 BRKMSG:    DB       "Break",0
  570                   ;
  571 039C 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  572 039F 39                      ADD      HL,SP       ; same index as specifi
  573 03A0 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  574 03A1 23                      INC      HL          ; Point to index addres
  575 03A2 FE81                    CP       ZFOR        ; Is it a "FOR" token
  576 03A4 C0                      RET      NZ          ; No - exit
  577 03A5 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  578 03A6 23                      INC      HL
  579 03A7 46                      LD       B,(HL)
  580 03A8 23                      INC      HL          ; Point to sign of STEP
  581 03A9 E5                      PUSH     HL          ; Save pointer to sign
  582 03AA 69                      LD       L,C         ; HL = address of "FOR"
  583 03AB 60                      LD       H,B
  584 03AC 7A                      LD       A,D         ; See if an index was s
  585 03AD B3                      OR       E           ; DE = 0 if no index sp
  586 03AE EB                      EX       DE,HL       ; Specified index into 
  587 03AF CAB603                  JP       Z,INDFND    ; Skip if no index give
  588 03B2 EB                      EX       DE,HL       ; Index back into DE
  589 03B3 CDBB06                  CALL     CPDEHL      ; Compare index with on
  590 03B6 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  591 03B9 E1                      POP      HL          ; Restore pointer to si
  592 03BA C8                      RET      Z           ; Return if block found
  593 03BB 09                      ADD      HL,BC       ; Point to next block
  594 03BC C3A003                  JP       LOKFOR      ; Keep on looking
  595                   ;
  596 03BF CDD903       MOVUP:     CALL     ENFMEM      ; See if enough memory
  597 03C2 C5           MOVSTR:    PUSH     BC          ; Save end of source
  598 03C3 E3                      EX       (SP),HL     ; Swap source and dest"
  599 03C4 C1                      POP      BC          ; Get end of destinatio
  600 03C5 CDBB06       MOVLP:     CALL     CPDEHL      ; See if list moved
  601 03C8 7E                      LD       A,(HL)      ; Get byte
  602 03C9 02                      LD       (BC),A      ; Move it
  603 03CA C8                      RET      Z           ; Exit if all done
  604 03CB 0B                      DEC      BC          ; Next byte to move to
  605 03CC 2B                      DEC      HL          ; Next byte to move
  606 03CD C3C503                  JP       MOVLP       ; Loop until all bytes 
  607                   ;
  608 03D0 E5           CHKSTK:    PUSH     HL          ; Save code string addr
  609 03D1 2A1F81                  LD       HL,(ARREND) ; Lowest free memory
  610 03D4 0600                    LD       B,0         ; BC = Number of levels
  611 03D6 09                      ADD      HL,BC       ; 2 Bytes for each leve
  612 03D7 09                      ADD      HL,BC
  613 03D8 3E                      DB       3EH         ; Skip "PUSH HL"
  614 03D9 E5           ENFMEM:    PUSH     HL          ; Save code string addr
  615 03DA 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  616 03DC 95                      SUB      L
  617 03DD 6F                      LD       L,A
  618 03DE 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  619 03E0 9C                      SBC      A,H
  620 03E1 DAE803                  JP       C,OMERR     ; Not enough - ?OM Erro
  621 03E4 67                      LD       H,A
  622 03E5 39                      ADD      HL,SP       ; Test if stack is over
  623 03E6 E1                      POP      HL          ; Restore code string a
  624 03E7 D8                      RET      C           ; Return if enough mmor
  625 03E8 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  626 03EA C30704                  JP       ERROR
  627                   ;
  628 03ED 2A0E81       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  629 03F0 22A180                  LD       (LINEAT),HL ; Save as current line
  630 03F3 1E02         SNERR:     LD       E,SN        ; ?SN Error
  631 03F5 01                      DB       01H         ; Skip "LD E,DZ"
  632 03F6 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  633 03F8 01                      DB       01H         ; Skip "LD E,NF"
  634 03F9 1E00         NFERR:     LD       E,NF        ; ?NF Error
  635 03FB 01                      DB       01H         ; Skip "LD E,RD"
  636 03FC 1E12         DDERR:     LD       E,RD        ; ?DD Error
  637 03FE 01                      DB       01H         ; Skip "LD E,UF"
  638 03FF 1E22         UFERR:     LD       E,UF        ; ?UF Error
  639 0401 01                      DB       01H         ; Skip "LD E,OV
  640 0402 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  641 0404 01                      DB       01H         ; Skip "LD E,TM"
  642 0405 1E18         TMERR:     LD       E,TM        ; ?TM Error
  643                   ;
  644 0407 CD2505       ERROR:     CALL     CLREG       ; Clear registers and s
  645 040A 328A80                  LD       (CTLOFG),A  ; Enable output (A is 0
  646 040D CDE60A                  CALL     STTLIN      ; Start new line
  647 0410 21FA02                  LD       HL,ERRORS   ; Point to error codes
  648 0413 57                      LD       D,A         ; D = 0 (A is 0)
  649 0414 3E3F                    LD       A,'?'
  650 0416 CDCC06                  CALL     OUTC        ; Output '?'
  651 0419 19                      ADD      HL,DE       ; Offset to correct err
  652 041A 7E                      LD       A,(HL)      ; First character
  653 041B CDCC06                  CALL     OUTC        ; Output it
  654 041E CD4B08                  CALL     GETCHR      ; Get next character
  655 0421 CDCC06                  CALL     OUTC        ; Output it
  656 0424 218403                  LD       HL,ERRMSG   ; "Error" message
  657 0427 CD9111       ERRIN:     CALL     PRS         ; Output message
  658 042A 2AA180                  LD       HL,(LINEAT) ; Get line of error
  659 042D 11FEFF                  LD       DE,-2       ; Cold start error if -
  660 0430 CDBB06                  CALL     CPDEHL      ; See if cold start err
  661 0433 CA4C00                  JP       Z,CSTART    ; Cold start error - Re
  662 0436 7C                      LD       A,H         ; Was it a direct error
  663 0437 A5                      AND      L           ; Line = -1 if direct e
  664 0438 3C                      INC      A
  665 0439 C42C18                  CALL     NZ,LINEIN   ; No - output line of e
  666 043C 3E                      DB       3EH         ; Skip "POP BC"
  667 043D C1           POPNOK:    POP      BC          ; Drop address in input
  668                   ;
  669 043E AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  670 043F 328A80                  LD       (CTLOFG),A  ; Enable output
  671 0442 CDE60A                  CALL     STTLIN      ; Start new line
  672 0445 219003                  LD       HL,OKMSG    ; "Ok" message
  673 0448 CD9111                  CALL     PRS         ; Output "Ok"
  674 044B 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  675 044E 22A180                  LD       (LINEAT),HL ; Save as current line
  676 0451 CD3806                  CALL     GETLIN      ; Get an input line
  677 0454 DA4B04                  JP       C,GETCMD    ; Get line again if bre
  678 0457 CD4B08                  CALL     GETCHR      ; Get first character
  679 045A 3C                      INC      A           ; Test if end of line
  680 045B 3D                      DEC      A           ; Without affecting Car
  681 045C CA4B04                  JP       Z,GETCMD    ; Nothing entered - Get
  682 045F F5                      PUSH     AF          ; Save Carry status
  683 0460 CD1709                  CALL     ATOH        ; Get line number into 
  684 0463 D5                      PUSH     DE          ; Save line number
  685 0464 CD4F05                  CALL     CRUNCH      ; Tokenise rest of line
  686 0467 47                      LD       B,A         ; Length of tokenised l
  687 0468 D1                      POP      DE          ; Restore line number
  688 0469 F1                      POP      AF          ; Restore Carry
  689 046A D22B08                  JP       NC,EXCUTE   ; No line number - Dire
  690 046D D5                      PUSH     DE          ; Save line number
  691 046E C5                      PUSH     BC          ; Save length of tokeni
  692 046F AF                      XOR      A
  693 0470 321181                  LD       (LSTBIN),A  ; Clear last byte input
  694 0473 CD4B08                  CALL     GETCHR      ; Get next character
  695 0476 B7                      OR       A           ; Set flags
  696 0477 F5                      PUSH     AF          ; And save them
  697 0478 CDDF04                  CALL     SRCHLN      ; Search for line numbe
  698 047B DA8404                  JP       C,LINFND    ; Jump if line found
  699 047E F1                      POP      AF          ; Get status
  700 047F F5                      PUSH     AF          ; And re-save
  701 0480 CAB809                  JP       Z,ULERR     ; Nothing after number 
  702 0483 B7                      OR       A           ; Clear Carry
  703 0484 C5           LINFND:    PUSH     BC          ; Save address of line 
  704 0485 D29B04                  JP       NC,INEWLN   ; Line not found - Inse
  705 0488 EB                      EX       DE,HL       ; Next line address in 
  706 0489 2A1B81                  LD       HL,(PROGND) ; End of program
  707 048C 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  708 048D 02                      LD       (BC),A
  709 048E 03                      INC      BC          ; Next destination
  710 048F 13                      INC      DE          ; Next source
  711 0490 CDBB06                  CALL     CPDEHL      ; All done?
  712 0493 C28C04                  JP       NZ,SFTPRG   ; More to do
  713 0496 60                      LD       H,B         ; HL - New end of progr
  714 0497 69                      LD       L,C
  715 0498 221B81                  LD       (PROGND),HL ; Update end of program
  716                   ;
  717 049B D1           INEWLN:    POP      DE          ; Get address of line,
  718 049C F1                      POP      AF          ; Get status
  719 049D CAC204                  JP       Z,SETPTR    ; No text - Set up poin
  720 04A0 2A1B81                  LD       HL,(PROGND) ; Get end of program
  721 04A3 E3                      EX       (SP),HL     ; Get length of input l
  722 04A4 C1                      POP      BC          ; End of program to BC
  723 04A5 09                      ADD      HL,BC       ; Find new end
  724 04A6 E5                      PUSH     HL          ; Save new end
  725 04A7 CDBF03                  CALL     MOVUP       ; Make space for line
  726 04AA E1                      POP      HL          ; Restore new end
  727 04AB 221B81                  LD       (PROGND),HL ; Update end of program
  728 04AE EB                      EX       DE,HL       ; Get line to move up i
  729 04AF 74                      LD       (HL),H      ; Save MSB
  730 04B0 D1                      POP      DE          ; Get new line number
  731 04B1 23                      INC      HL          ; Skip pointer
  732 04B2 23                      INC      HL
  733 04B3 73                      LD       (HL),E      ; Save LSB of line numb
  734 04B4 23                      INC      HL
  735 04B5 72                      LD       (HL),D      ; Save MSB of line numb
  736 04B6 23                      INC      HL          ; To first byte in line
  737 04B7 11A680                  LD       DE,BUFFER   ; Copy buffer to progra
  738 04BA 1A           MOVBUF:    LD       A,(DE)      ; Get source
  739 04BB 77                      LD       (HL),A      ; Save destinations
  740 04BC 23                      INC      HL          ; Next source
  741 04BD 13                      INC      DE          ; Next destination
  742 04BE B7                      OR       A           ; Done?
  743 04BF C2BA04                  JP       NZ,MOVBUF   ; No - Repeat
  744 04C2 CD0B05       SETPTR:    CALL     RUNFST      ; Set line pointers
  745 04C5 23                      INC      HL          ; To LSB of pointer
  746 04C6 EB                      EX       DE,HL       ; Address to DE
  747 04C7 62           PTRLP:     LD       H,D         ; Address to HL
  748 04C8 6B                      LD       L,E
  749 04C9 7E                      LD       A,(HL)      ; Get LSB of pointer
  750 04CA 23                      INC      HL          ; To MSB of pointer
  751 04CB B6                      OR       (HL)        ; Compare with MSB poin
  752 04CC CA4B04                  JP       Z,GETCMD    ; Get command line if e
  753 04CF 23                      INC      HL          ; To LSB of line number
  754 04D0 23                      INC      HL          ; Skip line number
  755 04D1 23                      INC      HL          ; Point to first byte i
  756 04D2 AF                      XOR      A           ; Looking for 00 byte
  757 04D3 BE           FNDEND:    CP       (HL)        ; Found end of line?
  758 04D4 23                      INC      HL          ; Move to next byte
  759 04D5 C2D304                  JP       NZ,FNDEND   ; No - Keep looking
  760 04D8 EB                      EX       DE,HL       ; Next line address to 
  761 04D9 73                      LD       (HL),E      ; Save LSB of pointer
  762 04DA 23                      INC      HL
  763 04DB 72                      LD       (HL),D      ; Save MSB of pointer
  764 04DC C3C704                  JP       PTRLP       ; Do next line
  765                   ;
  766 04DF 2AA380       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  767 04E2 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  768 04E3 4D                      LD       C,L
  769 04E4 7E                      LD       A,(HL)      ; Get address of next l
  770 04E5 23                      INC      HL
  771 04E6 B6                      OR       (HL)        ; End of program found?
  772 04E7 2B                      DEC      HL
  773 04E8 C8                      RET      Z           ; Yes - Line not found
  774 04E9 23                      INC      HL
  775 04EA 23                      INC      HL
  776 04EB 7E                      LD       A,(HL)      ; Get LSB of line numbe
  777 04EC 23                      INC      HL
  778 04ED 66                      LD       H,(HL)      ; Get MSB of line numbe
  779 04EE 6F                      LD       L,A
  780 04EF CDBB06                  CALL     CPDEHL      ; Compare with line in 
  781 04F2 60                      LD       H,B         ; HL = Start of this li
  782 04F3 69                      LD       L,C
  783 04F4 7E                      LD       A,(HL)      ; Get LSB of next line 
  784 04F5 23                      INC      HL
  785 04F6 66                      LD       H,(HL)      ; Get MSB of next line 
  786 04F7 6F                      LD       L,A         ; Next line to HL
  787 04F8 3F                      CCF
  788 04F9 C8                      RET      Z           ; Lines found - Exit
  789 04FA 3F                      CCF
  790 04FB D0                      RET      NC          ; Line not found,at lin
  791 04FC C3E204                  JP       SRCHLP      ; Keep looking
  792                   ;
  793 04FF C0           NEW:       RET      NZ          ; Return if any more on
  794 0500 2AA380       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  795 0503 AF                      XOR      A           ; Set program area to e
  796 0504 77                      LD       (HL),A      ; Save LSB = 00
  797 0505 23                      INC      HL
  798 0506 77                      LD       (HL),A      ; Save MSB = 00
  799 0507 23                      INC      HL
  800 0508 221B81                  LD       (PROGND),HL ; Set program end
  801                   ;
  802 050B 2AA380       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  803 050E 2B                      DEC      HL
  804                   ;
  805 050F 221381       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  806 0512 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
  807 0515 220881                  LD       (STRBOT),HL ; Clear string space
  808 0518 AF                      XOR      A
  809 0519 CD5B08                  CALL     RESTOR      ; Reset DATA pointers
  810 051C 2A1B81                  LD       HL,(PROGND) ; Get end of program
  811 051F 221D81                  LD       (VAREND),HL ; Clear variables
  812 0522 221F81                  LD       (ARREND),HL ; Clear arrays
  813                   ;
  814 0525 C1           CLREG:     POP      BC          ; Save return address
  815 0526 2A9F80                  LD       HL,(STRSPC) ; Get end of working RA
  816 0529 F9                      LD       SP,HL       ; Set stack
  817 052A 21F880                  LD       HL,TMSTPL   ; Temporary string pool
  818 052D 22F680                  LD       (TMSTPT),HL ; Reset temporary strin
  819 0530 AF                      XOR      A           ; A = 00
  820 0531 6F                      LD       L,A         ; HL = 0000
  821 0532 67                      LD       H,A
  822 0533 221981                  LD       (CONTAD),HL ; No CONTinue
  823 0536 321081                  LD       (FORFLG),A  ; Clear FOR flag
  824 0539 222381                  LD       (FNRGNM),HL ; Clear FN argument
  825 053C E5                      PUSH     HL          ; HL = 0000
  826 053D C5                      PUSH     BC          ; Put back return
  827 053E 2A1381       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  828 0541 C9                      RET                  ; Return to execution d
  829                   ;
  830 0542 3E3F         PROMPT:    LD       A,'?'       ; '?'
  831 0544 CDCC06                  CALL     OUTC        ; Output character
  832 0547 3E20                    LD       A,' '       ; Space
  833 0549 CDCC06                  CALL     OUTC        ; Output character
  834 054C C39380                  JP       RINPUT      ; Get input line
  835                   ;
  836 054F AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  837 0550 32F380                  LD       (DATFLG),A  ; Reset literal flag
  838 0553 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  839 0555 11A680                  LD       DE,BUFFER   ; Start of input buffer
  840 0558 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  841 0559 FE20                    CP       ' '         ; Is it a space?
  842 055B CAD705                  JP       Z,MOVDIR    ; Yes - Copy direct
  843 055E 47                      LD       B,A         ; Save character
  844 055F FE22                    CP       '"'         ; Is it a quote?
  845 0561 CAF705                  JP       Z,CPYLIT    ; Yes - Copy literal st
  846 0564 B7                      OR       A           ; Is it end of buffer?
  847 0565 CAFE05                  JP       Z,ENDBUF    ; Yes - End buffer
  848 0568 3AF380                  LD       A,(DATFLG)  ; Get data type
  849 056B B7                      OR       A           ; Literal?
  850 056C 7E                      LD       A,(HL)      ; Get byte to copy
  851 056D C2D705                  JP       NZ,MOVDIR   ; Literal - Copy direct
  852 0570 FE3F                    CP       '?'         ; Is it '?' short for P
  853 0572 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  854 0574 CAD705                  JP       Z,MOVDIR    ; Yes - replace it
  855 0577 7E                      LD       A,(HL)      ; Get byte again
  856 0578 FE30                    CP       '0'         ; Is it less than '0'
  857 057A DA8205                  JP       C,FNDWRD    ; Yes - Look for reserv
  858 057D FE3C                    CP       60          ; ";"+1; Is it "0123456
  859 057F DAD705                  JP       C,MOVDIR    ; Yes - copy it direct
  860 0582 D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  861 0583 117B01                  LD       DE,WORDS-1  ; Point to table
  862 0586 C5                      PUSH     BC          ; Save count
  863 0587 01D305                  LD       BC,RETNAD   ; Where to return to
  864 058A C5                      PUSH     BC          ; Save return address
  865 058B 067F                    LD       B,ZEND-1    ; First token value -1
  866 058D 7E                      LD       A,(HL)      ; Get byte
  867 058E FE61                    CP       'a'         ; Less than 'a' ?
  868 0590 DA9B05                  JP       C,SEARCH    ; Yes - search for word
  869 0593 FE7B                    CP       'z'+1       ; Greater than 'z' ?
  870 0595 D29B05                  JP       NC,SEARCH   ; Yes - search for word
  871 0598 E65F                    AND      01011111B   ; Force upper case
  872 059A 77                      LD       (HL),A      ; Replace byte
  873 059B 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  874 059C EB                      EX       DE,HL
  875 059D 23           GETNXT:    INC      HL          ; Get next reserved wor
  876 059E B6                      OR       (HL)        ; Start of word?
  877 059F F29D05                  JP       P,GETNXT    ; No - move on
  878 05A2 04                      INC      B           ; Increment token value
  879 05A3 7E                      LD       A, (HL)     ; Get byte from table
  880 05A4 E67F                    AND      01111111B   ; Strip bit 7
  881 05A6 C8                      RET      Z           ; Return if end of list
  882 05A7 B9                      CP       C           ; Same character as in 
  883 05A8 C29D05                  JP       NZ,GETNXT   ; No - get next word
  884 05AB EB                      EX       DE,HL
  885 05AC E5                      PUSH     HL          ; Save start of word
  886                   ;
  887 05AD 13           NXTBYT:    INC      DE          ; Look through rest of 
  888 05AE 1A                      LD       A,(DE)      ; Get byte from table
  889 05AF B7                      OR       A           ; End of word ?
  890 05B0 FACF05                  JP       M,MATCH     ; Yes - Match found
  891 05B3 4F                      LD       C,A         ; Save it
  892 05B4 78                      LD       A,B         ; Get token value
  893 05B5 FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  894 05B7 C2BE05                  JP       NZ,NOSPC    ; No - Don't allow spac
  895 05BA CD4B08                  CALL     GETCHR      ; Get next character
  896 05BD 2B                      DEC      HL          ; Cancel increment from
  897 05BE 23           NOSPC:     INC      HL          ; Next byte
  898 05BF 7E                      LD       A,(HL)      ; Get byte
  899 05C0 FE61                    CP       'a'         ; Less than 'a' ?
  900 05C2 DAC705                  JP       C,NOCHNG    ; Yes - don't change
  901 05C5 E65F                    AND      01011111B   ; Make upper case
  902 05C7 B9           NOCHNG:    CP       C           ; Same as in buffer ?
  903 05C8 CAAD05                  JP       Z,NXTBYT    ; Yes - keep testing
  904 05CB E1                      POP      HL          ; Get back start of wor
  905 05CC C39B05                  JP       SEARCH      ; Look at next word
  906                   ;
  907 05CF 48           MATCH:     LD       C,B         ; Word found - Save tok
  908 05D0 F1                      POP      AF          ; Throw away return
  909 05D1 EB                      EX       DE,HL
  910 05D2 C9                      RET                  ; Return to "RETNAD"
  911 05D3 EB           RETNAD:    EX       DE,HL       ; Get address in string
  912 05D4 79                      LD       A,C         ; Get token value
  913 05D5 C1                      POP      BC          ; Restore buffer length
  914 05D6 D1                      POP      DE          ; Get destination addre
  915 05D7 23           MOVDIR:    INC      HL          ; Next source in buffer
  916 05D8 12                      LD       (DE),A      ; Put byte in buffer
  917 05D9 13                      INC      DE          ; Move up buffer
  918 05DA 0C                      INC      C           ; Increment length of b
  919 05DB D63A                    SUB      ':'         ; End of statement?
  920 05DD CAE505                  JP       Z,SETLIT    ; Jump if multi-stateme
  921 05E0 FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
  922 05E2 C2E805                  JP       NZ,TSTREM   ; No - see if REM
  923 05E5 32F380       SETLIT:    LD       (DATFLG),A  ; Set literal flag
  924 05E8 D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
  925 05EA C25805                  JP       NZ,CRNCLP   ; No - Leave flag
  926 05ED 47                      LD       B,A         ; Copy rest of buffer
  927 05EE 7E           NXTCHR:    LD       A,(HL)      ; Get byte
  928 05EF B7                      OR       A           ; End of line ?
  929 05F0 CAFE05                  JP       Z,ENDBUF    ; Yes - Terminate buffe
  930 05F3 B8                      CP       B           ; End of statement ?
  931 05F4 CAD705                  JP       Z,MOVDIR    ; Yes - Get next one
  932 05F7 23           CPYLIT:    INC      HL          ; Move up source string
  933 05F8 12                      LD       (DE),A      ; Save in destination
  934 05F9 0C                      INC      C           ; Increment length
  935 05FA 13                      INC      DE          ; Move up destination
  936 05FB C3EE05                  JP       NXTCHR      ; Repeat
  937                   ;
  938 05FE 21A580       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
  939 0601 12                      LD       (DE),A      ; Mark end of buffer (A
  940 0602 13                      INC      DE
  941 0603 12                      LD       (DE),A      ; A = 00
  942 0604 13                      INC      DE
  943 0605 12                      LD       (DE),A      ; A = 00
  944 0606 C9                      RET
  945                   ;
  946 0607 3A8980       DODEL:     LD       A,(NULFLG)  ; Get null flag status
  947 060A B7                      OR       A           ; Is it zero?
  948 060B 3E00                    LD       A,0         ; Zero A - Leave flags
  949 060D 328980                  LD       (NULFLG),A  ; Zero null flag
  950 0610 C21B06                  JP       NZ,ECHDEL   ; Set - Echo it
  951 0613 05                      DEC      B           ; Decrement length
  952 0614 CA3806                  JP       Z,GETLIN    ; Get line again if emp
  953 0617 CDCC06                  CALL     OUTC        ; Output null character
  954 061A 3E                      DB       3EH         ; Skip "DEC B"
  955 061B 05           ECHDEL:    DEC      B           ; Count bytes in buffer
  956 061C 2B                      DEC      HL          ; Back space buffer
  957 061D CA2F06                  JP       Z,OTKLN     ; No buffer - Try again
  958 0620 7E                      LD       A,(HL)      ; Get deleted byte
  959 0621 CDCC06                  CALL     OUTC        ; Echo it
  960 0624 C34106                  JP       MORINP      ; Get more input
  961                   ;
  962 0627 05           DELCHR:    DEC      B           ; Count bytes in buffer
  963 0628 2B                      DEC      HL          ; Back space buffer
  964 0629 CDCC06                  CALL     OUTC        ; Output character in A
  965 062C C24106                  JP       NZ,MORINP   ; Not end - Get more
  966 062F CDCC06       OTKLN:     CALL     OUTC        ; Output character in A
  967 0632 CDF30A       KILIN:     CALL     PRCRLF      ; Output CRLF
  968 0635 C33806                  JP       TTYLIN      ; Get line again
  969                   ;
  970 0638              GETLIN:
  971 0638 21A680       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
  972 063B 0601                    LD       B,1         ; Set buffer as empty
  973 063D AF                      XOR      A
  974 063E 328980                  LD       (NULFLG),A  ; Clear null flag
  975 0641 CDF606       MORINP:    CALL     CLOTST      ; Get character and tes
  976 0644 4F                      LD       C,A         ; Save character in C
  977 0645 FE7F                    CP       DEL         ; Delete character?
  978 0647 CA0706                  JP       Z,DODEL     ; Yes - Process it
  979 064A 3A8980                  LD       A,(NULFLG)  ; Get null flag
  980 064D B7                      OR       A           ; Test null flag status
  981 064E CA5A06                  JP       Z,PROCES    ; Reset - Process chara
  982 0651 3E00                    LD       A,0         ; Set a null
  983 0653 CDCC06                  CALL     OUTC        ; Output null
  984 0656 AF                      XOR      A           ; Clear A
  985 0657 328980                  LD       (NULFLG),A  ; Reset null flag
  986 065A 79           PROCES:    LD       A,C         ; Get character
  987 065B FE07                    CP       CTRLG       ; Bell?
  988 065D CA9E06                  JP       Z,PUTCTL    ; Yes - Save it
  989 0660 FE03                    CP       CTRLC       ; Is it control "C"?
  990 0662 CCF30A                  CALL     Z,PRCRLF    ; Yes - Output CRLF
  991 0665 37                      SCF                  ; Flag break
  992 0666 C8                      RET      Z           ; Return if control "C"
  993 0667 FE0D                    CP       CR          ; Is it enter?
  994 0669 CAEE0A                  JP       Z,ENDINP    ; Yes - Terminate input
  995 066C FE15                    CP       CTRLU       ; Is it control "U"?
  996 066E CA3206                  JP       Z,KILIN     ; Yes - Get another lin
  997 0671 FE40                    CP       '@'         ; Is it "kill line"?
  998 0673 CA2F06                  JP       Z,OTKLN     ; Yes - Kill line
  999 0676 FE5F                    CP       '_'         ; Is it delete?
 1000 0678 CA2706                  JP       Z,DELCHR    ; Yes - Delete characte
 1001 067B FE08                    CP       BKSP        ; Is it backspace?
 1002 067D CA2706                  JP       Z,DELCHR    ; Yes - Delete characte
 1003 0680 FE12                    CP       CTRLR       ; Is it control "R"?
 1004 0682 C29906                  JP       NZ,PUTBUF   ; No - Put in buffer
 1005 0685 C5                      PUSH     BC          ; Save buffer length
 1006 0686 D5                      PUSH     DE          ; Save DE
 1007 0687 E5                      PUSH     HL          ; Save buffer address
 1008 0688 3600                    LD       (HL),0      ; Mark end of buffer
 1009 068A CD9D1C                  CALL     OUTNCR      ; Output and do CRLF
 1010 068D 21A680                  LD       HL,BUFFER   ; Point to buffer start
 1011 0690 CD9111                  CALL     PRS         ; Output buffer
 1012 0693 E1                      POP      HL          ; Restore buffer addres
 1013 0694 D1                      POP      DE          ; Restore DE
 1014 0695 C1                      POP      BC          ; Restore buffer length
 1015 0696 C34106                  JP       MORINP      ; Get another character
 1016                   ;
 1017 0699 FE20         PUTBUF:    CP       ' '         ; Is it a control code?
 1018 069B DA4106                  JP       C,MORINP    ; Yes - Ignore
 1019 069E 78           PUTCTL:    LD       A,B         ; Get number of bytes i
 1020 069F FE49                    CP       72+1        ; Test for line overflo
 1021 06A1 3E07                    LD       A,CTRLG     ; Set a bell
 1022 06A3 D2B306                  JP       NC,OUTNBS   ; Ring bell if buffer f
 1023 06A6 79                      LD       A,C         ; Get character
 1024 06A7 71                      LD       (HL),C      ; Save in buffer
 1025 06A8 321181                  LD       (LSTBIN),A  ; Save last input byte
 1026 06AB 23                      INC      HL          ; Move up buffer
 1027 06AC 04                      INC      B           ; Increment length
 1028 06AD CDCC06       OUTIT:     CALL     OUTC        ; Output the character 
 1029 06B0 C34106                  JP       MORINP      ; Get another character
 1030                   ;
 1031 06B3 CDCC06       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1032 06B6 3E08                    LD       A,BKSP      ; Set back space
 1033 06B8 C3AD06                  JP       OUTIT       ; Output it and get mor
 1034                   ;
 1035 06BB 7C           CPDEHL:    LD       A,H         ; Get H
 1036 06BC 92                      SUB      D           ; Compare with D
 1037 06BD C0                      RET      NZ          ; Different - Exit
 1038 06BE 7D                      LD       A,L         ; Get L
 1039 06BF 93                      SUB      E           ; Compare with E
 1040 06C0 C9                      RET                  ; Return status
 1041                   ;
 1042 06C1 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1043 06C2 E3                      EX       (SP),HL     ; Address of test byte
 1044 06C3 BE                      CP       (HL)        ; Same as in code strin
 1045 06C4 23                      INC      HL          ; Return address
 1046 06C5 E3                      EX       (SP),HL     ; Put it back
 1047 06C6 CA4B08                  JP       Z,GETCHR    ; Yes - Get next charac
 1048 06C9 C3F303                  JP       SNERR       ; Different - ?SN Error
 1049                   ;
 1050 06CC F5           OUTC:      PUSH     AF          ; Save character
 1051 06CD 3A8A80                  LD       A,(CTLOFG)  ; Get control "O" flag
 1052 06D0 B7                      OR       A           ; Is it set?
 1053 06D1 C2C611                  JP       NZ,POPAF    ; Yes - don't output
 1054 06D4 F1                      POP      AF          ; Restore character
 1055 06D5 C5                      PUSH     BC          ; Save buffer length
 1056 06D6 F5                      PUSH     AF          ; Save character
 1057 06D7 FE20                    CP       ' '         ; Is it a control code?
 1058 06D9 DAF006                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1059 06DC 3A8780                  LD       A,(LWIDTH)  ; Get line width
 1060 06DF 47                      LD       B,A         ; To B
 1061 06E0 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1062 06E3 04                      INC      B           ; Width 255?
 1063 06E4 CAEC06                  JP       Z,INCLEN    ; Yes - No width limit
 1064 06E7 05                      DEC      B           ; Restore width
 1065 06E8 B8                      CP       B           ; At end of line?
 1066 06E9 CCF30A                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1067 06EC 3C           INCLEN:    INC      A           ; Move on one character
 1068 06ED 32F080                  LD       (CURPOS),A  ; Save new position
 1069 06F0 F1           DINPOS:    POP      AF          ; Restore character
 1070 06F1 C1                      POP      BC          ; Restore buffer length
 1071 06F2 CD881C                  CALL     MONOUT      ; Send it
 1072 06F5 C9                      RET
 1073                   ;
 1074 06F6 CD501B       CLOTST:    CALL     GETINP      ; Get input character
 1075 06F9 E67F                    AND      01111111B   ; Strip bit 7
 1076 06FB FE0F                    CP       CTRLO       ; Is it control "O"?
 1077 06FD C0                      RET      NZ          ; No don't flip flag
 1078 06FE 3A8A80                  LD       A,(CTLOFG)  ; Get flag
 1079 0701 2F                      CPL                  ; Flip it
 1080 0702 328A80                  LD       (CTLOFG),A  ; Put it back
 1081 0705 AF                      XOR      A           ; Null character
 1082 0706 C9                      RET
 1083                   ;
 1084 0707 CD1709       LIST:      CALL     ATOH        ; ASCII number to DE
 1085 070A C0                      RET      NZ          ; Return if anything ex
 1086 070B C1                      POP      BC          ; Rubbish - Not needed
 1087 070C CDDF04                  CALL     SRCHLN      ; Search for line numbe
 1088 070F C5                      PUSH     BC          ; Save address of line
 1089 0710 CD5D07                  CALL     SETLIN      ; Set up lines counter
 1090 0713 E1           LISTLP:    POP      HL          ; Restore address of li
 1091 0714 4E                      LD       C,(HL)      ; Get LSB of next line
 1092 0715 23                      INC      HL
 1093 0716 46                      LD       B,(HL)      ; Get MSB of next line
 1094 0717 23                      INC      HL
 1095 0718 78                      LD       A,B         ; BC = 0 (End of progra
 1096 0719 B1                      OR       C
 1097 071A CA3E04                  JP       Z,PRNTOK    ; Yes - Go to command m
 1098 071D CD6607                  CALL     COUNT       ; Count lines
 1099 0720 CD7608                  CALL     TSTBRK      ; Test for break key
 1100 0723 C5                      PUSH     BC          ; Save address of next 
 1101 0724 CDF30A                  CALL     PRCRLF      ; Output CRLF
 1102 0727 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1103 0728 23                      INC      HL
 1104 0729 56                      LD       D,(HL)      ; Get MSB of line numbe
 1105 072A 23                      INC      HL
 1106 072B E5                      PUSH     HL          ; Save address of line 
 1107 072C EB                      EX       DE,HL       ; Line number to HL
 1108 072D CD3418                  CALL     PRNTHL      ; Output line number in
 1109 0730 3E20                    LD       A,' '       ; Space after line numb
 1110 0732 E1                      POP      HL          ; Restore start of line
 1111 0733 CDCC06       LSTLP2:    CALL     OUTC        ; Output character in A
 1112 0736 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1113 0737 B7                      OR       A           ; End of line?
 1114 0738 23                      INC      HL          ; To next byte in line
 1115 0739 CA1307                  JP       Z,LISTLP    ; Yes - get next line
 1116 073C F23307                  JP       P,LSTLP2    ; No token - output it
 1117 073F D67F                    SUB      ZEND-1      ; Find and output word
 1118 0741 4F                      LD       C,A         ; Token offset+1 to C
 1119 0742 117C01                  LD       DE,WORDS    ; Reserved word list
 1120 0745 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1121 0746 13                      INC      DE          ; Move on to next
 1122 0747 B7                      OR       A           ; Is it start of word?
 1123 0748 F24507                  JP       P,FNDTOK    ; No - Keep looking for
 1124 074B 0D                      DEC      C           ; Count words
 1125 074C C24507                  JP       NZ,FNDTOK   ; Not there - keep look
 1126 074F E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1127 0751 CDCC06                  CALL     OUTC        ; Output first characte
 1128 0754 1A                      LD       A,(DE)      ; Get next character
 1129 0755 13                      INC      DE          ; Move on to next
 1130 0756 B7                      OR       A           ; Is it end of word?
 1131 0757 F24F07                  JP       P,OUTWRD    ; No - output the rest
 1132 075A C33607                  JP       LSTLP3      ; Next byte in line
 1133                   ;
 1134 075D E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1135 075E 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1136 0761 228B80                  LD       (LINESC),HL ; Save in LINES counter
 1137 0764 E1                      POP      HL
 1138 0765 C9                      RET
 1139                   ;
 1140 0766 E5           COUNT:     PUSH     HL          ; Save code string addr
 1141 0767 D5                      PUSH     DE
 1142 0768 2A8B80                  LD       HL,(LINESC) ; Get LINES counter
 1143 076B 11FFFF                  LD       DE,-1
 1144 076E ED5A                    ADC      HL,DE       ; Decrement
 1145 0770 228B80                  LD       (LINESC),HL ; Put it back
 1146 0773 D1                      POP      DE
 1147 0774 E1                      POP      HL          ; Restore code string a
 1148 0775 F0                      RET      P           ; Return if more lines 
 1149 0776 E5                      PUSH     HL          ; Save code string addr
 1150 0777 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1151 077A 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1152 077D CD501B                  CALL     GETINP      ; Get input character
 1153 0780 FE03                    CP       CTRLC       ; Is it control "C"?
 1154 0782 CA8907                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1155 0785 E1                      POP      HL          ; Restore code string a
 1156 0786 C36607                  JP       COUNT       ; Keep on counting
 1157                   ;
 1158 0789 2A8D80       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1159 078C 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1160 078F C3BD00                  JP       BRKRET      ; Go and output "Break"
 1161                   ;
 1162 0792 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1163 0794 321081                  LD       (FORFLG),A  ; Save "FOR" flag
 1164 0797 CDF909                  CALL     LET         ; Set up initial index
 1165 079A C1                      POP      BC          ; Drop RETurn address
 1166 079B E5                      PUSH     HL          ; Save code string addr
 1167 079C CDE209                  CALL     DATA        ; Get next statement ad
 1168 079F 220C81                  LD       (LOOPST),HL ; Save it for start of 
 1169 07A2 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1170 07A5 39                      ADD      HL,SP       ; Point to it
 1171 07A6 CDA003       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1172 07A9 D1                      POP      DE          ; Get code string addre
 1173 07AA C2C207                  JP       NZ,FORFND   ; No nesting found
 1174 07AD 09                      ADD      HL,BC       ; Move into "FOR" block
 1175 07AE D5                      PUSH     DE          ; Save code string addr
 1176 07AF 2B                      DEC      HL
 1177 07B0 56                      LD       D,(HL)      ; Get MSB of loop state
 1178 07B1 2B                      DEC      HL
 1179 07B2 5E                      LD       E,(HL)      ; Get LSB of loop state
 1180 07B3 23                      INC      HL
 1181 07B4 23                      INC      HL
 1182 07B5 E5                      PUSH     HL          ; Save block address
 1183 07B6 2A0C81                  LD       HL,(LOOPST) ; Get address of loop s
 1184 07B9 CDBB06                  CALL     CPDEHL      ; Compare the FOR loops
 1185 07BC E1                      POP      HL          ; Restore block address
 1186 07BD C2A607                  JP       NZ,FORSLP   ; Different FORs - Find
 1187 07C0 D1                      POP      DE          ; Restore code string a
 1188 07C1 F9                      LD       SP,HL       ; Remove all nested loo
 1189                   ;
 1190 07C2 EB           FORFND:    EX       DE,HL       ; Code string address t
 1191 07C3 0E08                    LD       C,8
 1192 07C5 CDD003                  CALL     CHKSTK      ; Check for 8 levels of
 1193 07C8 E5                      PUSH     HL          ; Save code string addr
 1194 07C9 2A0C81                  LD       HL,(LOOPST) ; Get first statement o
 1195 07CC E3                      EX       (SP),HL     ; Save and restore code
 1196 07CD E5                      PUSH     HL          ; Re-save code string a
 1197 07CE 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 1198 07D1 E3                      EX       (SP),HL     ; Save and restore code
 1199 07D2 CDBB0C                  CALL     TSTNUM      ; Make sure it's a numb
 1200 07D5 CDC106                  CALL     CHKSYN      ; Make sure "TO" is nex
 1201 07D8 A6                      DB       ZTO         ; "TO" token
 1202 07D9 CDB80C                  CALL     GETNUM      ; Get "TO" expression v
 1203 07DC E5                      PUSH     HL          ; Save code string addr
 1204 07DD CDE616                  CALL     BCDEFP      ; Move "TO" value to BC
 1205 07E0 E1                      POP      HL          ; Restore code string a
 1206 07E1 C5                      PUSH     BC          ; Save "TO" value in bl
 1207 07E2 D5                      PUSH     DE
 1208 07E3 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1209 07E6 51                      LD       D,C         ; C=0
 1210 07E7 5A                      LD       E,D         ; D=0
 1211 07E8 7E                      LD       A,(HL)      ; Get next byte in code
 1212 07E9 FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1213 07EB 3E01                    LD       A,1         ; Sign of step = 1
 1214 07ED C2FE07                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1215 07F0 CD4B08                  CALL     GETCHR      ; Jump over "STEP" toke
 1216 07F3 CDB80C                  CALL     GETNUM      ; Get step value
 1217 07F6 E5                      PUSH     HL          ; Save code string addr
 1218 07F7 CDE616                  CALL     BCDEFP      ; Move STEP to BCDE
 1219 07FA CD9A16                  CALL     TSTSGN      ; Test sign of FPREG
 1220 07FD E1                      POP      HL          ; Restore code string a
 1221 07FE C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1222 07FF D5                      PUSH     DE
 1223 0800 F5                      PUSH     AF          ; Save sign of STEP
 1224 0801 33                      INC      SP          ; Don't save flags
 1225 0802 E5                      PUSH     HL          ; Save code string addr
 1226 0803 2A1381                  LD       HL,(BRKLIN) ; Get address of index 
 1227 0806 E3                      EX       (SP),HL     ; Save and restore code
 1228 0807 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1229 0809 C5                      PUSH     BC          ; Save it
 1230 080A 33                      INC      SP          ; Don't save C
 1231                   ;
 1232 080B CD7608       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1233 080E 221381                  LD       (BRKLIN),HL ; Save code address for
 1234 0811 7E                      LD       A,(HL)      ; Get next byte in code
 1235 0812 FE3A                    CP       ':'         ; Multi statement line?
 1236 0814 CA2B08                  JP       Z,EXCUTE    ; Yes - Execute it
 1237 0817 B7                      OR       A           ; End of line?
 1238 0818 C2F303                  JP       NZ,SNERR    ; No - Syntax error
 1239 081B 23                      INC      HL          ; Point to address of n
 1240 081C 7E                      LD       A,(HL)      ; Get LSB of line point
 1241 081D 23                      INC      HL
 1242 081E B6                      OR       (HL)        ; Is it zero (End of pr
 1243 081F CA9D08                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1244 0822 23                      INC      HL          ; Point to line number
 1245 0823 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1246 0824 23                      INC      HL
 1247 0825 56                      LD       D,(HL)      ; Get MSB of line numbe
 1248 0826 EB                      EX       DE,HL       ; Line number to HL
 1249 0827 22A180                  LD       (LINEAT),HL ; Save as current line 
 1250 082A EB                      EX       DE,HL       ; Line number back to D
 1251 082B CD4B08       EXCUTE:    CALL     GETCHR      ; Get key word
 1252 082E 110B08                  LD       DE,RUNCNT   ; Where to RETurn to
 1253 0831 D5                      PUSH     DE          ; Save for RETurn
 1254 0832 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1255 0833 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1256 0835 DAF909                  JP       C,LET       ; No - try to assign it
 1257 0838 FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1258 083A D2F303                  JP       NC,SNERR    ; Not a key word - ?SN 
 1259 083D 07                      RLCA                 ; Double it
 1260 083E 4F                      LD       C,A         ; BC = Offset into tabl
 1261 083F 0600                    LD       B,0
 1262 0841 EB                      EX       DE,HL       ; Save code string addr
 1263 0842 219B02                  LD       HL,WORDTB   ; Keyword address table
 1264 0845 09                      ADD      HL,BC       ; Point to routine addr
 1265 0846 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1266 0847 23                      INC      HL
 1267 0848 46                      LD       B,(HL)      ; Get MSB of routine ad
 1268 0849 C5                      PUSH     BC          ; Save routine address
 1269 084A EB                      EX       DE,HL       ; Restore code string a
 1270                   ;
 1271 084B 23           GETCHR:    INC      HL          ; Point to next charact
 1272 084C 7E                      LD       A,(HL)      ; Get next code string 
 1273 084D FE3A                    CP       ':'         ; Z if ':'
 1274 084F D0                      RET      NC          ; NC if > "9"
 1275 0850 FE20                    CP       ' '
 1276 0852 CA4B08                  JP       Z,GETCHR    ; Skip over spaces
 1277 0855 FE30                    CP       '0'
 1278 0857 3F                      CCF                  ; NC if < '0'
 1279 0858 3C                      INC      A           ; Test for zero - Leave
 1280 0859 3D                      DEC      A           ; Z if Null
 1281 085A C9                      RET
 1282                   ;
 1283 085B EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1284 085C 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1285 085F CA7008                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1286 0862 EB                      EX       DE,HL       ; Restore code string a
 1287 0863 CD1709                  CALL     ATOH        ; Get line number to DE
 1288 0866 E5                      PUSH     HL          ; Save code string addr
 1289 0867 CDDF04                  CALL     SRCHLN      ; Search for line numbe
 1290 086A 60                      LD       H,B         ; HL = Address of line
 1291 086B 69                      LD       L,C
 1292 086C D1                      POP      DE          ; Restore code string a
 1293 086D D2B809                  JP       NC,ULERR    ; ?UL Error if not foun
 1294 0870 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1295 0871 222181       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1296 0874 EB                      EX       DE,HL       ; Restore code string a
 1297 0875 C9                      RET
 1298                   ;
 1299                   
 1300 0876 DF           TSTBRK:    RST      18H         ; Check input status
 1301 0877 C8                      RET      Z           ; No key, go back
 1302 0878 D7                      RST      10H         ; Get the key into A
 1303 0879 FE1B                    CP       ESC         ; Escape key?
 1304 087B 2811                    JR       Z,BRK       ; Yes, break
 1305 087D FE03                    CP       CTRLC       ; <Ctrl-C>
 1306 087F 280D                    JR       Z,BRK       ; Yes, break
 1307 0881 FE13                    CP       CTRLS       ; Stop scrolling?
 1308 0883 C0                      RET      NZ          ; Other key, ignore
 1309                   ;
 1310                   
 1311 0884 D7           STALL:     RST      10H         ; Wait for key
 1312 0885 FE11                    CP       CTRLQ       ; Resume scrolling?
 1313 0887 C8                      RET      Z           ; Release the chokehold
 1314 0888 FE03                    CP       CTRLC       ; Second break?
 1315 088A 2807                    JR       Z,STOP      ; Break during hold exi
 1316 088C 18F6                    JR       STALL       ; Loop until <Ctrl-Q> o
 1317                   ;
 1318 088E 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1319 0890 329280                  LD       (BRKFLG),A  ; Store it
 1320                   ;
 1321                   
 1322 0893 C0           STOP:      RET      NZ          ; Exit if anything else
 1323 0894 F6                      DB       0F6H        ; Flag "STOP"
 1324 0895 C0           PEND:      RET      NZ          ; Exit if anything else
 1325 0896 221381                  LD       (BRKLIN),HL ; Save point of break
 1326 0899 21                      DB       21H         ; Skip "OR 11111111B"
 1327 089A F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1328 089C C1                      POP      BC          ; Return not needed and
 1329 089D 2AA180       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1330 08A0 F5                      PUSH     AF          ; Save STOP / END statu
 1331 08A1 7D                      LD       A,L         ; Is it direct break?
 1332 08A2 A4                      AND      H
 1333 08A3 3C                      INC      A           ; Line is -1 if direct 
 1334 08A4 CAB008                  JP       Z,NOLIN     ; Yes - No line number
 1335 08A7 221781                  LD       (ERRLIN),HL ; Save line of break
 1336 08AA 2A1381                  LD       HL,(BRKLIN) ; Get point of break
 1337 08AD 221981                  LD       (CONTAD),HL ; Save point to CONTinu
 1338 08B0 AF           NOLIN:     XOR      A
 1339 08B1 328A80                  LD       (CTLOFG),A  ; Enable output
 1340 08B4 CDE60A                  CALL     STTLIN      ; Start a new line
 1341 08B7 F1                      POP      AF          ; Restore STOP / END st
 1342 08B8 219603                  LD       HL,BRKMSG   ; "Break" message
 1343 08BB C22704                  JP       NZ,ERRIN    ; "in line" wanted?
 1344 08BE C33E04                  JP       PRNTOK      ; Go to command mode
 1345                   ;
 1346 08C1 2A1981       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1347 08C4 7C                      LD       A,H         ; Is it zero?
 1348 08C5 B5                      OR       L
 1349 08C6 1E20                    LD       E,CN        ; ?CN Error
 1350 08C8 CA0704                  JP       Z,ERROR     ; Yes - output "?CN Err
 1351 08CB EB                      EX       DE,HL       ; Save code string addr
 1352 08CC 2A1781                  LD       HL,(ERRLIN) ; Get line of last brea
 1353 08CF 22A180                  LD       (LINEAT),HL ; Set up current line n
 1354 08D2 EB                      EX       DE,HL       ; Restore code string a
 1355 08D3 C9                      RET                  ; CONTinue where left o
 1356                   ;
 1357 08D4 CD1914       NULL:      CALL     GETINT      ; Get integer 0-255
 1358 08D7 C0                      RET      NZ          ; Return if bad value
 1359 08D8 328680                  LD       (NULLS),A   ; Set nulls number
 1360 08DB C9                      RET
 1361                   ;
 1362                   
 1363 08DC E5           ACCSUM:    PUSH     HL          ; Save address in array
 1364 08DD 2A8F80                  LD       HL,(CHKSUM) ; Get check sum
 1365 08E0 0600                    LD       B,0         ; BC - Value of byte
 1366 08E2 4F                      LD       C,A
 1367 08E3 09                      ADD      HL,BC       ; Add byte to check sum
 1368 08E4 228F80                  LD       (CHKSUM),HL ; Re-save check sum
 1369 08E7 E1                      POP      HL          ; Restore address in ar
 1370 08E8 C9                      RET
 1371                   ;
 1372 08E9 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1373 08EA FE41                    CP       'A'         ; < 'a' ?
 1374 08EC D8                      RET      C           ; Carry set if not lett
 1375 08ED FE5B                    CP       'Z'+1       ; > 'z' ?
 1376 08EF 3F                      CCF
 1377 08F0 C9                      RET                  ; Carry set if not lett
 1378                   ;
 1379 08F1 CD4B08       FPSINT:    CALL     GETCHR      ; Get next character
 1380 08F4 CDB80C       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1381 08F7 CD9A16       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1382 08FA FA1209                  JP       M,FCERR     ; Negative - ?FC Error
 1383 08FD 3A2C81       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1384 0900 FE90                    CP       80H+16      ; Exponent in range (16
 1385 0902 DA4217                  JP       C,FPINT     ; Yes - convert it
 1386 0905 018090                  LD       BC,9080H    ; BCDE = -32768
 1387 0908 110000                  LD       DE,0000
 1388 090B E5                      PUSH     HL          ; Save code string addr
 1389 090C CD1517                  CALL     CMPNUM      ; Compare FPREG with BC
 1390 090F E1                      POP      HL          ; Restore code string a
 1391 0910 51                      LD       D,C         ; MSB to D
 1392 0911 C8                      RET      Z           ; Return if in range
 1393 0912 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1394 0914 C30704                  JP       ERROR       ; Output error-
 1395                   ;
 1396 0917 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1397 0918 110000       GETLN:     LD       DE,0        ; Get number to DE
 1398 091B CD4B08       GTLNLP:    CALL     GETCHR      ; Get next character
 1399 091E D0                      RET      NC          ; Exit if not a digit
 1400 091F E5                      PUSH     HL          ; Save code string addr
 1401 0920 F5                      PUSH     AF          ; Save digit
 1402 0921 219819                  LD       HL,65529/10 ; Largest number 65529
 1403 0924 CDBB06                  CALL     CPDEHL      ; Number in range?
 1404 0927 DAF303                  JP       C,SNERR     ; No - ?SN Error
 1405 092A 62                      LD       H,D         ; HL = Number
 1406 092B 6B                      LD       L,E
 1407 092C 19                      ADD      HL,DE       ; Times 2
 1408 092D 29                      ADD      HL,HL       ; Times 4
 1409 092E 19                      ADD      HL,DE       ; Times 5
 1410 092F 29                      ADD      HL,HL       ; Times 10
 1411 0930 F1                      POP      AF          ; Restore digit
 1412 0931 D630                    SUB      '0'         ; Make it 0 to 9
 1413 0933 5F                      LD       E,A         ; DE = Value of digit
 1414 0934 1600                    LD       D,0
 1415 0936 19                      ADD      HL,DE       ; Add to number
 1416 0937 EB                      EX       DE,HL       ; Number to DE
 1417 0938 E1                      POP      HL          ; Restore code string a
 1418 0939 C31B09                  JP       GTLNLP      ; Go to next character
 1419                   ;
 1420 093C CA0F05       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1421 093F CDF408                  CALL     POSINT      ; Get integer 0 to 3276
 1422 0942 2B                      DEC      HL          ; Cancel increment
 1423 0943 CD4B08                  CALL     GETCHR      ; Get next character
 1424 0946 E5                      PUSH     HL          ; Save code string addr
 1425 0947 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
 1426 094A CA5F09                  JP       Z,STORED    ; No value given - Use 
 1427 094D E1                      POP      HL          ; Restore code string a
 1428 094E CDC106                  CALL     CHKSYN      ; Check for comma
 1429 0951 2C                      DB       ','
 1430 0952 D5                      PUSH     DE          ; Save number
 1431 0953 CDF408                  CALL     POSINT      ; Get integer 0 to 3276
 1432 0956 2B                      DEC      HL          ; Cancel increment
 1433 0957 CD4B08                  CALL     GETCHR      ; Get next character
 1434 095A C2F303                  JP       NZ,SNERR    ; ?SN Error if more on 
 1435 095D E3                      EX       (SP),HL     ; Save code string addr
 1436 095E EB                      EX       DE,HL       ; Number to DE
 1437 095F 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1438 0960 93                      SUB      E           ; Subtract LSB of strin
 1439 0961 5F                      LD       E,A         ; Save LSB
 1440 0962 7C                      LD       A,H         ; Get MSB of new RAM to
 1441 0963 9A                      SBC      A,D         ; Subtract MSB of strin
 1442 0964 57                      LD       D,A         ; Save MSB
 1443 0965 DAE803                  JP       C,OMERR     ; ?OM Error if not enou
 1444 0968 E5                      PUSH     HL          ; Save RAM top
 1445 0969 2A1B81                  LD       HL,(PROGND) ; Get program end
 1446 096C 012800                  LD       BC,40       ; 40 Bytes minimum work
 1447 096F 09                      ADD      HL,BC       ; Get lowest address
 1448 0970 CDBB06                  CALL     CPDEHL      ; Enough memory?
 1449 0973 D2E803                  JP       NC,OMERR    ; No - ?OM Error
 1450 0976 EB                      EX       DE,HL       ; RAM top to HL
 1451 0977 229F80                  LD       (STRSPC),HL ; Set new string space
 1452 097A E1                      POP      HL          ; End of memory to use
 1453 097B 22F480                  LD       (LSTRAM),HL ; Set new top of RAM
 1454 097E E1                      POP      HL          ; Restore code string a
 1455 097F C30F05                  JP       INTVAR      ; Initialise variables
 1456                   ;
 1457 0982 CA0B05       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1458 0985 CD0F05                  CALL     INTVAR      ; Initialise variables
 1459 0988 010B08                  LD       BC,RUNCNT   ; Execution driver loop
 1460 098B C39E09                  JP       RUNLIN      ; RUN from line number
 1461                   ;
 1462 098E 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1463 0990 CDD003                  CALL     CHKSTK      ; Check for 3 levels of
 1464 0993 C1                      POP      BC          ; Get return address
 1465 0994 E5                      PUSH     HL          ; Save code string for 
 1466 0995 E5                      PUSH     HL          ; And for GOSUB routine
 1467 0996 2AA180                  LD       HL,(LINEAT) ; Get current line
 1468 0999 E3                      EX       (SP),HL     ; Into stack - Code str
 1469 099A 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1470 099C F5                      PUSH     AF          ; Save token
 1471 099D 33                      INC      SP          ; Don't save flags
 1472                   ;
 1473 099E C5           RUNLIN:    PUSH     BC          ; Save return address
 1474 099F CD1709       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1475 09A2 CDE409                  CALL     REM         ; Get end of line
 1476 09A5 E5                      PUSH     HL          ; Save end of line
 1477 09A6 2AA180                  LD       HL,(LINEAT) ; Get current line
 1478 09A9 CDBB06                  CALL     CPDEHL      ; Line after current?
 1479 09AC E1                      POP      HL          ; Restore end of line
 1480 09AD 23                      INC      HL          ; Start of next line
 1481 09AE DCE204                  CALL     C,SRCHLP    ; Line is after current
 1482 09B1 D4DF04                  CALL     NC,SRCHLN   ; Line is before curren
 1483 09B4 60                      LD       H,B         ; Set up code string ad
 1484 09B5 69                      LD       L,C
 1485 09B6 2B                      DEC      HL          ; Incremented after
 1486 09B7 D8                      RET      C           ; Line found
 1487 09B8 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1488 09BA C30704                  JP       ERROR       ; Output error message
 1489                   ;
 1490 09BD C0           RETURN:    RET      NZ          ; Return if not just RE
 1491 09BE 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1492 09C0 CD9C03                  CALL     BAKSTK      ; Look "GOSUB" block
 1493 09C3 F9                      LD       SP,HL       ; Kill all FORs in subr
 1494 09C4 FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1495 09C6 1E04                    LD       E,RG        ; ?RG Error
 1496 09C8 C20704                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1497 09CB E1                      POP      HL          ; Get RETURN line numbe
 1498 09CC 22A180                  LD       (LINEAT),HL ; Save as current
 1499 09CF 23                      INC      HL          ; Was it from direct st
 1500 09D0 7C                      LD       A,H
 1501 09D1 B5                      OR       L           ; Return to line
 1502 09D2 C2DC09                  JP       NZ,RETLIN   ; No - Return to line
 1503 09D5 3A1181                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1504 09D8 B7                      OR       A           ; If so buffer is corru
 1505 09D9 C23D04                  JP       NZ,POPNOK   ; Yes - Go to command m
 1506 09DC 210B08       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1507 09DF E3                      EX       (SP),HL     ; Into stack - Code str
 1508 09E0 3E                      DB       3EH         ; Skip "POP HL"
 1509 09E1 E1           NXTDTA:    POP      HL          ; Restore code string a
 1510                   ;
 1511 09E2 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1512 09E4 0E00         REM:       LD       C,0         ; 00    End of statemen
 1513 09E6 0600                    LD       B,0
 1514 09E8 79           NXTSTL:    LD       A,C         ; Statement and byte
 1515 09E9 48                      LD       C,B
 1516 09EA 47                      LD       B,A         ; Statement end byte
 1517 09EB 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1518 09EC B7                      OR       A           ; End of line?
 1519 09ED C8                      RET      Z           ; Yes - Exit
 1520 09EE B8                      CP       B           ; End of statement?
 1521 09EF C8                      RET      Z           ; Yes - Exit
 1522 09F0 23                      INC      HL          ; Next byte
 1523 09F1 FE22                    CP       '"'         ; Literal string?
 1524 09F3 CAE809                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1525 09F6 C3EB09                  JP       NXTSTT      ; Keep looking
 1526                   ;
 1527 09F9 CDAE0E       LET:       CALL     GETVAR      ; Get variable name
 1528 09FC CDC106                  CALL     CHKSYN      ; Make sure "=" follows
 1529 09FF B4                      DB       ZEQUAL      ; "=" token
 1530 0A00 D5                      PUSH     DE          ; Save address of varia
 1531 0A01 3AF280                  LD       A,(TYPE)    ; Get data type
 1532 0A04 F5                      PUSH     AF          ; Save type
 1533 0A05 CDCA0C                  CALL     EVAL        ; Evaluate expression
 1534 0A08 F1                      POP      AF          ; Restore type
 1535 0A09 E3                      EX       (SP),HL     ; Save code - Get var a
 1536 0A0A 221381                  LD       (BRKLIN),HL ; Save address of varia
 1537 0A0D 1F                      RRA                  ; Adjust type
 1538 0A0E CDBD0C                  CALL     CHKTYP      ; Check types are the s
 1539 0A11 CA4C0A                  JP       Z,LETNUM    ; Numeric - Move value
 1540 0A14 E5           LETSTR:    PUSH     HL          ; Save address of strin
 1541 0A15 2A2981                  LD       HL,(FPREG)  ; Pointer to string ent
 1542 0A18 E5                      PUSH     HL          ; Save it on stack
 1543 0A19 23                      INC      HL          ; Skip over length
 1544 0A1A 23                      INC      HL
 1545 0A1B 5E                      LD       E,(HL)      ; LSB of string address
 1546 0A1C 23                      INC      HL
 1547 0A1D 56                      LD       D,(HL)      ; MSB of string address
 1548 0A1E 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1549 0A21 CDBB06                  CALL     CPDEHL      ; Is string before prog
 1550 0A24 D23B0A                  JP       NC,CRESTR   ; Yes - Create string e
 1551 0A27 2A9F80                  LD       HL,(STRSPC) ; Point to string space
 1552 0A2A CDBB06                  CALL     CPDEHL      ; Is string literal in 
 1553 0A2D D1                      POP      DE          ; Restore address of st
 1554 0A2E D2430A                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1555 0A31 210481                  LD       HL,TMPSTR   ; Temporary string pool
 1556 0A34 CDBB06                  CALL     CPDEHL      ; Is string in temporar
 1557 0A37 D2430A                  JP       NC,MVSTPT   ; No - Set up pointer
 1558 0A3A 3E                      DB       3EH         ; Skip "POP DE"
 1559 0A3B D1           CRESTR:    POP      DE          ; Restore address of st
 1560 0A3C CDF212                  CALL     BAKTMP      ; Back to last tmp-str 
 1561 0A3F EB                      EX       DE,HL       ; Address of string ent
 1562 0A40 CD2B11                  CALL     SAVSTR      ; Save string in string
 1563 0A43 CDF212       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1564 0A46 E1                      POP      HL          ; Get string pointer
 1565 0A47 CDF516                  CALL     DETHL4      ; Move string pointer t
 1566 0A4A E1                      POP      HL          ; Restore code string a
 1567 0A4B C9                      RET
 1568                   ;
 1569 0A4C E5           LETNUM:    PUSH     HL          ; Save address of varia
 1570 0A4D CDF216                  CALL     FPTHL       ; Move value to variabl
 1571 0A50 D1                      POP      DE          ; Restore address of va
 1572 0A51 E1                      POP      HL          ; Restore code string a
 1573 0A52 C9                      RET
 1574                   ;
 1575 0A53 CD1914       ON:        CALL     GETINT      ; Get integer 0-255
 1576 0A56 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1577 0A57 47                      LD       B,A         ; Save in B
 1578 0A58 FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1579 0A5A CA620A                  JP       Z,ONGO      ; Yes - Find line numbe
 1580 0A5D CDC106                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1581 0A60 88                      DB       ZGOTO       ; "GOTO" token
 1582 0A61 2B                      DEC      HL          ; Cancel increment
 1583 0A62 4B           ONGO:      LD       C,E         ; Integer of branch val
 1584 0A63 0D           ONGOLP:    DEC      C           ; Count branches
 1585 0A64 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1586 0A65 CA3308                  JP       Z,ONJMP     ; Go to that line if ri
 1587 0A68 CD1809                  CALL     GETLN       ; Get line number to DE
 1588 0A6B FE2C                    CP       ','         ; Another line number?
 1589 0A6D C0                      RET      NZ          ; No - Drop through
 1590 0A6E C3630A                  JP       ONGOLP      ; Yes - loop
 1591                   ;
 1592 0A71 CDCA0C       IF:        CALL     EVAL        ; Evaluate expression
 1593 0A74 7E                      LD       A,(HL)      ; Get token
 1594 0A75 FE88                    CP       ZGOTO       ; "GOTO" token?
 1595 0A77 CA7F0A                  JP       Z,IFGO      ; Yes - Get line
 1596 0A7A CDC106                  CALL     CHKSYN      ; Make sure it's "THEN"
 1597 0A7D A9                      DB       ZTHEN       ; "THEN" token
 1598 0A7E 2B                      DEC      HL          ; Cancel increment
 1599 0A7F CDBB0C       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1600 0A82 CD9A16                  CALL     TSTSGN      ; Test state of express
 1601 0A85 CAE409                  JP       Z,REM       ; False - Drop through
 1602 0A88 CD4B08                  CALL     GETCHR      ; Get next character
 1603 0A8B DA9F09                  JP       C,GOTO      ; Number - GOTO that li
 1604 0A8E C33208                  JP       IFJMP       ; Otherwise do statemen
 1605                   ;
 1606 0A91 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1607 0A92 CD4B08                  CALL     GETCHR      ; Get next character
 1608 0A95 CAF30A       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1609 0A98 C8           PRNTLP:    RET      Z           ; End of list - Exit
 1610 0A99 FEA5                    CP       ZTAB        ; "TAB(" token?
 1611 0A9B CA260B                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1612 0A9E FEA8                    CP       ZSPC        ; "SPC(" token?
 1613 0AA0 CA260B                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1614 0AA3 E5                      PUSH     HL          ; Save code string addr
 1615 0AA4 FE2C                    CP       ','         ; Comma?
 1616 0AA6 CA0F0B                  JP       Z,DOCOM     ; Yes - Move to next zo
 1617 0AA9 FE3B                    CP       59          ;";"          ; Semi-co
 1618 0AAB CA490B                  JP       Z,NEXITM    ; Do semi-colon routine
 1619 0AAE C1                      POP      BC          ; Code string address t
 1620 0AAF CDCA0C                  CALL     EVAL        ; Evaluate expression
 1621 0AB2 E5                      PUSH     HL          ; Save code string addr
 1622 0AB3 3AF280                  LD       A,(TYPE)    ; Get variable type
 1623 0AB6 B7                      OR       A           ; Is it a string variab
 1624 0AB7 C2DF0A                  JP       NZ,PRNTST   ; Yes - Output string c
 1625 0ABA CD3F18                  CALL     NUMASC      ; Convert number to tex
 1626 0ABD CD4F11                  CALL     CRTST       ; Create temporary stri
 1627 0AC0 3620                    LD       (HL),' '    ; Followed by a space
 1628 0AC2 2A2981                  LD       HL,(FPREG)  ; Get length of output
 1629 0AC5 34                      INC      (HL)        ; Plus 1 for the space
 1630 0AC6 2A2981                  LD       HL,(FPREG)  ; < Not needed >
 1631 0AC9 3A8780                  LD       A,(LWIDTH)  ; Get width of line
 1632 0ACC 47                      LD       B,A         ; To B
 1633 0ACD 04                      INC      B           ; Width 255 (No limit)?
 1634 0ACE CADB0A                  JP       Z,PRNTNB    ; Yes - Output number s
 1635 0AD1 04                      INC      B           ; Adjust it
 1636 0AD2 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1637 0AD5 86                      ADD      A,(HL)      ; Add length of string
 1638 0AD6 3D                      DEC      A           ; Adjust it
 1639 0AD7 B8                      CP       B           ; Will output fit on th
 1640 0AD8 D4F30A                  CALL     NC,PRCRLF   ; No - CRLF first
 1641 0ADB CD9411       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1642 0ADE AF                      XOR      A           ; Skip CALL by setting 
 1643 0ADF C49411       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1644 0AE2 E1                      POP      HL          ; Restore code string a
 1645 0AE3 C3910A                  JP       MRPRNT      ; See if more to PRINT
 1646                   ;
 1647 0AE6 3AF080       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1648 0AE9 B7                      OR       A           ; Already at start?
 1649 0AEA C8                      RET      Z           ; Yes - Do nothing
 1650 0AEB C3F30A                  JP       PRCRLF      ; Start a new line
 1651                   ;
 1652 0AEE 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1653 0AF0 21A580                  LD       HL,BUFFER-1 ; Point to buffer
 1654 0AF3 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1655 0AF5 CDCC06                  CALL     OUTC        ; Output character
 1656 0AF8 3E0A                    LD       A,LF        ; Load a LF
 1657 0AFA CDCC06                  CALL     OUTC        ; Output character
 1658 0AFD AF           DONULL:    XOR      A           ; Set to position 0
 1659 0AFE 32F080                  LD       (CURPOS),A  ; Store it
 1660 0B01 3A8680                  LD       A,(NULLS)   ; Get number of nulls
 1661 0B04 3D           NULLP:     DEC      A           ; Count them
 1662 0B05 C8                      RET      Z           ; Return if done
 1663 0B06 F5                      PUSH     AF          ; Save count
 1664 0B07 AF                      XOR      A           ; Load a null
 1665 0B08 CDCC06                  CALL     OUTC        ; Output it
 1666 0B0B F1                      POP      AF          ; Restore count
 1667 0B0C C3040B                  JP       NULLP       ; Keep counting
 1668                   ;
 1669 0B0F 3A8880       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1670 0B12 47                      LD       B,A         ; Save in B
 1671 0B13 3AF080                  LD       A,(CURPOS)  ; Get current position
 1672 0B16 B8                      CP       B           ; Within the limit?
 1673 0B17 D4F30A                  CALL     NC,PRCRLF   ; No - output CRLF
 1674 0B1A D2490B                  JP       NC,NEXITM   ; Get next item
 1675 0B1D D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1676 0B1F D21D0B                  JP       NC,ZONELP   ; Repeat if more zones
 1677 0B22 2F                      CPL                  ; Number of spaces to o
 1678 0B23 C33E0B                  JP       ASPCS       ; Output them
 1679                   ;
 1680 0B26 F5           DOTAB:     PUSH     AF          ; Save token
 1681 0B27 CD1614                  CALL     FNDNUM      ; Evaluate expression
 1682 0B2A CDC106                  CALL     CHKSYN      ; Make sure ")" follows
 1683 0B2D 29                      DB       ")"
 1684 0B2E 2B                      DEC      HL          ; Back space on to ")"
 1685 0B2F F1                      POP      AF          ; Restore token
 1686 0B30 D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1687 0B32 E5                      PUSH     HL          ; Save code string addr
 1688 0B33 CA390B                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1689 0B36 3AF080                  LD       A,(CURPOS)  ; Get current position
 1690 0B39 2F           DOSPC:     CPL                  ; Number of spaces to p
 1691 0B3A 83                      ADD      A,E         ; Total number to print
 1692 0B3B D2490B                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1693 0B3E 3C           ASPCS:     INC      A           ; Output A spaces
 1694 0B3F 47                      LD       B,A         ; Save number to print
 1695 0B40 3E20                    LD       A,' '       ; Space
 1696 0B42 CDCC06       SPCLP:     CALL     OUTC        ; Output character in A
 1697 0B45 05                      DEC      B           ; Count them
 1698 0B46 C2420B                  JP       NZ,SPCLP    ; Repeat if more
 1699 0B49 E1           NEXITM:    POP      HL          ; Restore code string a
 1700 0B4A CD4B08                  CALL     GETCHR      ; Get next character
 1701 0B4D C3980A                  JP       PRNTLP      ; More to print
 1702                   ;
 1703 0B50 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1704                   ;
 1705 0B63 3A1281       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1706 0B66 B7                      OR       A
 1707 0B67 C2ED03                  JP       NZ,DATSNR   ; READ - ?SN Error
 1708 0B6A C1                      POP      BC          ; Throw away code strin
 1709 0B6B 21500B                  LD       HL,REDO     ; "Redo from start" mes
 1710 0B6E CD9111                  CALL     PRS         ; Output string
 1711 0B71 C33E05                  JP       DOAGN       ; Do last INPUT again
 1712                   ;
 1713 0B74 CDFC10       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1714 0B77 7E                      LD       A,(HL)      ; Get character after "
 1715 0B78 FE22                    CP       '"'         ; Is there a prompt str
 1716 0B7A 3E00                    LD       A,0         ; Clear A and leave fla
 1717 0B7C 328A80                  LD       (CTLOFG),A  ; Enable output
 1718 0B7F C28E0B                  JP       NZ,NOPMPT   ; No prompt - get input
 1719 0B82 CD5011                  CALL     QTSTR       ; Get string terminated
 1720 0B85 CDC106                  CALL     CHKSYN      ; Check for ';' after p
 1721 0B88 3B                      DB       ';'
 1722 0B89 E5                      PUSH     HL          ; Save code string addr
 1723 0B8A CD9411                  CALL     PRS1        ; Output prompt string
 1724 0B8D 3E                      DB       3EH         ; Skip "PUSH HL"
 1725 0B8E E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1726 0B8F CD4205                  CALL     PROMPT      ; Get input with "? " p
 1727 0B92 C1                      POP      BC          ; Restore code string a
 1728 0B93 DA9A08                  JP       C,INPBRK    ; Break pressed - Exit
 1729 0B96 23                      INC      HL          ; Next byte
 1730 0B97 7E                      LD       A,(HL)      ; Get it
 1731 0B98 B7                      OR       A           ; End of line?
 1732 0B99 2B                      DEC      HL          ; Back again
 1733 0B9A C5                      PUSH     BC          ; Re-save code string a
 1734 0B9B CAE109                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1735 0B9E 362C                    LD       (HL),','    ; Store comma as separa
 1736 0BA0 C3A80B                  JP       NXTITM      ; Get next item
 1737                   ;
 1738 0BA3 E5           READ:      PUSH     HL          ; Save code string addr
 1739 0BA4 2A2181                  LD       HL,(NXTDAT) ; Next DATA statement
 1740 0BA7 F6                      DB       0F6H        ; Flag "READ"
 1741 0BA8 AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1742 0BA9 321281                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1743 0BAC E3                      EX       (SP),HL     ; Get code str' , Save 
 1744 0BAD C3B40B                  JP       GTVLUS      ; Get values
 1745                   ;
 1746 0BB0 CDC106       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1747 0BB3 2C                      DB       ','
 1748 0BB4 CDAE0E       GTVLUS:    CALL     GETVAR      ; Get variable name
 1749 0BB7 E3                      EX       (SP),HL     ; Save code str" , Get 
 1750 0BB8 D5                      PUSH     DE          ; Save variable address
 1751 0BB9 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1752 0BBA FE2C                    CP       ','         ; Comma?
 1753 0BBC CADC0B                  JP       Z,ANTVLU    ; Yes - Get another val
 1754 0BBF 3A1281                  LD       A,(READFG)  ; Is it READ?
 1755 0BC2 B7                      OR       A
 1756 0BC3 C2490C                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1757 0BC6 3E3F                    LD       A,'?'       ; More INPUT needed
 1758 0BC8 CDCC06                  CALL     OUTC        ; Output character
 1759 0BCB CD4205                  CALL     PROMPT      ; Get INPUT with prompt
 1760 0BCE D1                      POP      DE          ; Variable address
 1761 0BCF C1                      POP      BC          ; Code string address
 1762 0BD0 DA9A08                  JP       C,INPBRK    ; Break pressed
 1763 0BD3 23                      INC      HL          ; Point to next DATA by
 1764 0BD4 7E                      LD       A,(HL)      ; Get byte
 1765 0BD5 B7                      OR       A           ; Is it zero (No input)
 1766 0BD6 2B                      DEC      HL          ; Back space INPUT poin
 1767 0BD7 C5                      PUSH     BC          ; Save code string addr
 1768 0BD8 CAE109                  JP       Z,NXTDTA    ; Find end of buffer
 1769 0BDB D5                      PUSH     DE          ; Save variable address
 1770 0BDC 3AF280       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1771 0BDF B7                      OR       A           ; Is it numeric?
 1772 0BE0 CA060C                  JP       Z,INPBIN    ; Yes - Convert to bina
 1773 0BE3 CD4B08                  CALL     GETCHR      ; Get next character
 1774 0BE6 57                      LD       D,A         ; Save input character
 1775 0BE7 47                      LD       B,A         ; Again
 1776 0BE8 FE22                    CP       '"'         ; Start of literal stin
 1777 0BEA CAFA0B                  JP       Z,STRENT    ; Yes - Create string e
 1778 0BED 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1779 0BF0 B7                      OR       A
 1780 0BF1 57                      LD       D,A         ; Save 00 if "INPUT"
 1781 0BF2 CAF70B                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1782 0BF5 163A                    LD       D,':'       ; "DATA" - End with 00 
 1783 0BF7 062C         ITMSEP:    LD       B,','       ; Item separator
 1784 0BF9 2B                      DEC      HL          ; Back space for DTSTR
 1785 0BFA CD5311       STRENT:    CALL     DTSTR       ; Get string terminated
 1786 0BFD EB                      EX       DE,HL       ; String address to DE
 1787 0BFE 21110C                  LD       HL,LTSTND   ; Where to go after LET
 1788 0C01 E3                      EX       (SP),HL     ; Save HL , get input p
 1789 0C02 D5                      PUSH     DE          ; Save address of strin
 1790 0C03 C3140A                  JP       LETSTR      ; Assign string to vari
 1791                   ;
 1792 0C06 CD4B08       INPBIN:    CALL     GETCHR      ; Get next character
 1793 0C09 CDA117                  CALL     ASCTFP      ; Convert ASCII to FP n
 1794 0C0C E3                      EX       (SP),HL     ; Save input ptr, Get v
 1795 0C0D CDF216                  CALL     FPTHL       ; Move FPREG to variabl
 1796 0C10 E1                      POP      HL          ; Restore input pointer
 1797 0C11 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1798 0C12 CD4B08                  CALL     GETCHR      ; Get next character
 1799 0C15 CA1D0C                  JP       Z,MORDT     ; End of line - More ne
 1800 0C18 FE2C                    CP       ','         ; Another value?
 1801 0C1A C2630B                  JP       NZ,BADINP   ; No - Bad input
 1802 0C1D E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1803 0C1E 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1804 0C1F CD4B08                  CALL     GETCHR      ; Get next character
 1805 0C22 C2B00B                  JP       NZ,NEDMOR   ; More needed - Get it
 1806 0C25 D1                      POP      DE          ; Restore DATA pointer
 1807 0C26 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1808 0C29 B7                      OR       A
 1809 0C2A EB                      EX       DE,HL       ; DATA pointer to HL
 1810 0C2B C27108                  JP       NZ,UPDATA   ; Update DATA pointer i
 1811 0C2E D5                      PUSH     DE          ; Save code string addr
 1812 0C2F B6                      OR       (HL)        ; More input given?
 1813 0C30 21380C                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1814 0C33 C49111                  CALL     NZ,PRS      ; Output string if extr
 1815 0C36 E1                      POP      HL          ; Restore code string a
 1816 0C37 C9                      RET
 1817                   ;
 1818 0C38 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1819                   ;
 1820 0C49 CDE209       FDTLP:     CALL     DATA        ; Get next statement
 1821 0C4C B7                      OR       A           ; End of line?
 1822 0C4D C2620C                  JP       NZ,FANDT    ; No - See if DATA stat
 1823 0C50 23                      INC      HL
 1824 0C51 7E                      LD       A,(HL)      ; End of program?
 1825 0C52 23                      INC      HL
 1826 0C53 B6                      OR       (HL)        ; 00 00 Ends program
 1827 0C54 1E06                    LD       E,OD        ; ?OD Error
 1828 0C56 CA0704                  JP       Z,ERROR     ; Yes - Out of DATA
 1829 0C59 23                      INC      HL
 1830 0C5A 5E                      LD       E,(HL)      ; LSB of line number
 1831 0C5B 23                      INC      HL
 1832 0C5C 56                      LD       D,(HL)      ; MSB of line number
 1833 0C5D EB                      EX       DE,HL
 1834 0C5E 220E81                  LD       (DATLIN),HL ; Set line of current D
 1835 0C61 EB                      EX       DE,HL
 1836 0C62 CD4B08       FANDT:     CALL     GETCHR      ; Get next character
 1837 0C65 FE83                    CP       ZDATA       ; "DATA" token
 1838 0C67 C2490C                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1839 0C6A C3DC0B                  JP       ANTVLU      ; Found - Convert input
 1840                   ;
 1841 0C6D 110000       NEXT:      LD       DE,0        ; In case no index give
 1842 0C70 C4AE0E       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1843 0C73 221381                  LD       (BRKLIN),HL ; Save code string addr
 1844 0C76 CD9C03                  CALL     BAKSTK      ; Look for "FOR" block
 1845 0C79 C2F903                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1846 0C7C F9                      LD       SP,HL       ; Clear nested loops
 1847 0C7D D5                      PUSH     DE          ; Save index address
 1848 0C7E 7E                      LD       A,(HL)      ; Get sign of STEP
 1849 0C7F 23                      INC      HL
 1850 0C80 F5                      PUSH     AF          ; Save sign of STEP
 1851 0C81 D5                      PUSH     DE          ; Save index address
 1852 0C82 CDD816                  CALL     PHLTFP      ; Move index value to F
 1853 0C85 E3                      EX       (SP),HL     ; Save address of TO va
 1854 0C86 E5                      PUSH     HL          ; Save address of index
 1855 0C87 CD4514                  CALL     ADDPHL      ; Add STEP to index val
 1856 0C8A E1                      POP      HL          ; Restore address of in
 1857 0C8B CDF216                  CALL     FPTHL       ; Move value to index v
 1858 0C8E E1                      POP      HL          ; Restore address of TO
 1859 0C8F CDE916                  CALL     LOADFP      ; Move TO value to BCDE
 1860 0C92 E5                      PUSH     HL          ; Save address of line 
 1861 0C93 CD1517                  CALL     CMPNUM      ; Compare index with TO
 1862 0C96 E1                      POP      HL          ; Restore address of li
 1863 0C97 C1                      POP      BC          ; Address of sign of ST
 1864 0C98 90                      SUB      B           ; Compare with expected
 1865 0C99 CDE916                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1866 0C9C CAA80C                  JP       Z,KILFOR    ; Loop finished - Termi
 1867 0C9F EB                      EX       DE,HL       ; Loop statement line n
 1868 0CA0 22A180                  LD       (LINEAT),HL ; Set loop line number
 1869 0CA3 69                      LD       L,C         ; Set code string to lo
 1870 0CA4 60                      LD       H,B
 1871 0CA5 C30708                  JP       PUTFID      ; Put back "FOR" and co
 1872                   ;
 1873 0CA8 F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1874 0CA9 2A1381                  LD       HL,(BRKLIN) ; Code string after "NE
 1875 0CAC 7E                      LD       A,(HL)      ; Get next byte in code
 1876 0CAD FE2C                    CP       ','         ; More NEXTs ?
 1877 0CAF C20B08                  JP       NZ,RUNCNT   ; No - Do next statemen
 1878 0CB2 CD4B08                  CALL     GETCHR      ; Position to index nam
 1879 0CB5 CD700C                  CALL     NEXT1       ; Re-enter NEXT routine
 1880                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1881                   ;
 1882 0CB8 CDCA0C       GETNUM:    CALL     EVAL        ; Get a numeric express
 1883 0CBB F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1884 0CBC 37           TSTSTR:    SCF                  ; Set carry (string)
 1885 0CBD 3AF280       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1886 0CC0 8F                      ADC      A,A         ; Expected + actual
 1887 0CC1 B7                      OR       A           ; Clear carry , set par
 1888 0CC2 E8                      RET      PE          ; Even parity - Types m
 1889 0CC3 C30504                  JP       TMERR       ; Different types - Err
 1890                   ;
 1891 0CC6 CDC106       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1892 0CC9 28                      DB       "("
 1893 0CCA 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1894 0CCB 1600                    LD       D,0         ; Precedence value
 1895 0CCD D5           EVAL1:     PUSH     DE          ; Save precedence
 1896 0CCE 0E01                    LD       C,1
 1897 0CD0 CDD003                  CALL     CHKSTK      ; Check for 1 level of 
 1898 0CD3 CD410D                  CALL     OPRND       ; Get next expression v
 1899 0CD6 221581       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1900 0CD9 2A1581       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 1901 0CDC C1                      POP      BC          ; Precedence value and 
 1902 0CDD 78                      LD       A,B         ; Get precedence value
 1903 0CDE FE78                    CP       78H         ; "AND" or "OR" ?
 1904 0CE0 D4BB0C                  CALL     NC,TSTNUM   ; No - Make sure it's a
 1905 0CE3 7E                      LD       A,(HL)      ; Get next operator / f
 1906 0CE4 1600                    LD       D,0         ; Clear Last relation
 1907 0CE6 D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 1908 0CE8 DA020D                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 1909 0CEB FE03                    CP       ZLTH+1-ZGTR ; < = >
 1910 0CED D2020D                  JP       NC,FOPRND   ; Function - Call it
 1911 0CF0 FE01                    CP       ZEQUAL-ZGTR ; "="
 1912 0CF2 17                      RLA                  ; <- Test for legal
 1913 0CF3 AA                      XOR      D           ; <- combinations of < 
 1914 0CF4 BA                      CP       D           ; <- by combining last 
 1915 0CF5 57                      LD       D,A         ; <- with current one
 1916 0CF6 DAF303                  JP       C,SNERR     ; Error if "<<' '==" or
 1917 0CF9 220A81                  LD       (CUROPR),HL ; Save address of curre
 1918 0CFC CD4B08                  CALL     GETCHR      ; Get next character
 1919 0CFF C3E60C                  JP       RLTLP       ; Treat the two as one
 1920                   ;
 1921 0D02 7A           FOPRND:    LD       A,D         ; < = > found ?
 1922 0D03 B7                      OR       A
 1923 0D04 C2290E                  JP       NZ,TSTRED   ; Yes - Test for reduct
 1924 0D07 7E                      LD       A,(HL)      ; Get operator token
 1925 0D08 220A81                  LD       (CUROPR),HL ; Save operator address
 1926 0D0B D6AC                    SUB      ZPLUS       ; Operator or function?
 1927 0D0D D8                      RET      C           ; Neither - Exit
 1928 0D0E FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 1929 0D10 D0                      RET      NC          ; No - Exit
 1930 0D11 5F                      LD       E,A         ; Coded operator
 1931 0D12 3AF280                  LD       A,(TYPE)    ; Get data type
 1932 0D15 3D                      DEC      A           ; FF = numeric , 00 = s
 1933 0D16 B3                      OR       E           ; Combine with coded op
 1934 0D17 7B                      LD       A,E         ; Get coded operator
 1935 0D18 CA8712                  JP       Z,CONCAT    ; String concatenation
 1936 0D1B 07                      RLCA                 ; Times 2
 1937 0D1C 83                      ADD      A,E         ; Times 3
 1938 0D1D 5F                      LD       E,A         ; To DE (D is 0)
 1939 0D1E 21E502                  LD       HL,PRITAB   ; Precedence table
 1940 0D21 19                      ADD      HL,DE       ; To the operator conce
 1941 0D22 78                      LD       A,B         ; Last operator precede
 1942 0D23 56                      LD       D,(HL)      ; Get evaluation preced
 1943 0D24 BA                      CP       D           ; Compare with eval pre
 1944 0D25 D0                      RET      NC          ; Exit if higher preced
 1945 0D26 23                      INC      HL          ; Point to routine addr
 1946 0D27 CDBB0C                  CALL     TSTNUM      ; Make sure it's a numb
 1947                   ;
 1948 0D2A C5           STKTHS:    PUSH     BC          ; Save last precedence 
 1949 0D2B 01D90C                  LD       BC,EVAL3    ; Where to go on prec' 
 1950 0D2E C5                      PUSH     BC          ; Save on stack for ret
 1951 0D2F 43                      LD       B,E         ; Save operator
 1952 0D30 4A                      LD       C,D         ; Save precedence
 1953 0D31 CDCB16                  CALL     STAKFP      ; Move value to stack
 1954 0D34 58                      LD       E,B         ; Restore operator
 1955 0D35 51                      LD       D,C         ; Restore precedence
 1956 0D36 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1957 0D37 23                      INC      HL
 1958 0D38 46                      LD       B,(HL)      ; Get MSB of routine ad
 1959 0D39 23                      INC      HL
 1960 0D3A C5                      PUSH     BC          ; Save routine address
 1961 0D3B 2A0A81                  LD       HL,(CUROPR) ; Address of current op
 1962 0D3E C3CD0C                  JP       EVAL1       ; Loop until prec' brea
 1963                   ;
 1964 0D41 AF           OPRND:     XOR      A           ; Get operand routine
 1965 0D42 32F280                  LD       (TYPE),A    ; Set numeric expected
 1966 0D45 CD4B08                  CALL     GETCHR      ; Get next character
 1967 0D48 1E24                    LD       E,MO        ; ?MO Error
 1968 0D4A CA0704                  JP       Z,ERROR     ; No operand - Error
 1969 0D4D DAA117                  JP       C,ASCTFP    ; Number - Get value
 1970 0D50 CDE908                  CALL     CHKLTR      ; See if a letter
 1971 0D53 D2A80D                  JP       NC,CONVAR   ; Letter - Find variabl
 1972 0D56 FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 1973 0D58 2012                    JR       NZ, NOTAMP
 1974 0D5A CD4B08                  CALL     GETCHR      ; Get next character
 1975 0D5D FE48                    CP       'H'         ; Hex number indicated?
 1976 0D5F CAE51B                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 1977 0D62 FE42                    CP       'B'         ; Binary number indicat
 1978 0D64 CA551C                  JP       Z,BINTFP    ; Convert Bin to FPREG
 1979 0D67 1E02                    LD       E,SN        ; If neither then a ?SN
 1980 0D69 CA0704                  JP       Z,ERROR
 1981 0D6C FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 1982 0D6E CA410D                  JP       Z,OPRND     ; Yes - Look for operan
 1983 0D71 FE2E                    CP       '.'         ; '.' ?
 1984 0D73 CAA117                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 1985 0D76 FEAD                    CP       ZMINUS      ; '-' Token ?
 1986 0D78 CA970D                  JP       Z,MINUS     ; Yes - Do minus
 1987 0D7B FE22                    CP       '"'         ; Literal string ?
 1988 0D7D CA5011                  JP       Z,QTSTR     ; Get string terminated
 1989 0D80 FEAA                    CP       ZNOT        ; "NOT" Token ?
 1990 0D82 CA890E                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 1991 0D85 FEA7                    CP       ZFN         ; "FN" Token ?
 1992 0D87 CAB410                  JP       Z,DOFN      ; Yes - Do FN routine
 1993 0D8A D6B6                    SUB      ZSGN        ; Is it a function?
 1994 0D8C D2B90D                  JP       NC,FNOFST   ; Yes - Evaluate functi
 1995 0D8F CDC60C       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 1996 0D92 CDC106                  CALL     CHKSYN      ; Make sure ")" follows
 1997 0D95 29                      DB       ")"
 1998 0D96 C9                      RET
 1999                   ;
 2000 0D97 167D         MINUS:     LD       D,7DH       ; '-' precedence
 2001 0D99 CDCD0C                  CALL     EVAL1       ; Evaluate until prec' 
 2002 0D9C 2A1581                  LD       HL,(NXTOPR) ; Get next operator add
 2003 0D9F E5                      PUSH     HL          ; Save next operator ad
 2004 0DA0 CDC316                  CALL     INVSGN      ; Negate value
 2005 0DA3 CDBB0C       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 2006 0DA6 E1                      POP      HL          ; Restore next operator
 2007 0DA7 C9                      RET
 2008                   ;
 2009 0DA8 CDAE0E       CONVAR:    CALL     GETVAR      ; Get variable address 
 2010 0DAB E5           FRMEVL:    PUSH     HL          ; Save code string addr
 2011 0DAC EB                      EX       DE,HL       ; Variable address to H
 2012 0DAD 222981                  LD       (FPREG),HL  ; Save address of varia
 2013 0DB0 3AF280                  LD       A,(TYPE)    ; Get type
 2014 0DB3 B7                      OR       A           ; Numeric?
 2015 0DB4 CCD816                  CALL     Z,PHLTFP    ; Yes - Move contents t
 2016 0DB7 E1                      POP      HL          ; Restore code string a
 2017 0DB8 C9                      RET
 2018                   ;
 2019 0DB9 0600         FNOFST:    LD       B,0         ; Get address of functi
 2020 0DBB 07                      RLCA                 ; Double function offse
 2021 0DBC 4F                      LD       C,A         ; BC = Offset in functi
 2022 0DBD C5                      PUSH     BC          ; Save adjusted token v
 2023 0DBE CD4B08                  CALL     GETCHR      ; Get next character
 2024 0DC1 79                      LD       A,C         ; Get adjusted token va
 2025 0DC2 FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2026 0DC4 DAE00D                  JP       C,FNVAL     ; No - Do function
 2027 0DC7 CDC60C                  CALL     OPNPAR      ; Evaluate expression  
 2028 0DCA CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 2029 0DCD 2C                      DB       ','
 2030 0DCE CDBC0C                  CALL     TSTSTR      ; Make sure it's a stri
 2031 0DD1 EB                      EX       DE,HL       ; Save code string addr
 2032 0DD2 2A2981                  LD       HL,(FPREG)  ; Get address of string
 2033 0DD5 E3                      EX       (SP),HL     ; Save address of strin
 2034 0DD6 E5                      PUSH     HL          ; Save adjusted token v
 2035 0DD7 EB                      EX       DE,HL       ; Restore code string a
 2036 0DD8 CD1914                  CALL     GETINT      ; Get integer 0-255
 2037 0DDB EB                      EX       DE,HL       ; Save code string addr
 2038 0DDC E3                      EX       (SP),HL     ; Save integer,HL = adj
 2039 0DDD C3E80D                  JP       GOFUNC      ; Jump to string functi
 2040                   ;
 2041 0DE0 CD8F0D       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2042 0DE3 E3                      EX       (SP),HL     ; HL = Adjusted token v
 2043 0DE4 11A30D                  LD       DE,RETNUM   ; Return number from fu
 2044 0DE7 D5                      PUSH     DE          ; Save on stack
 2045 0DE8 014401       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2046 0DEB 09                      ADD      HL,BC       ; Point to right addres
 2047 0DEC 4E                      LD       C,(HL)      ; Get LSB of address
 2048 0DED 23                      INC      HL          ;
 2049 0DEE 66                      LD       H,(HL)      ; Get MSB of address
 2050 0DEF 69                      LD       L,C         ; Address to HL
 2051 0DF0 E9                      JP       (HL)        ; Jump to function
 2052                   ;
 2053 0DF1 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2054 0DF2 FEAD                    CP       ZMINUS      ; '-' token ?
 2055 0DF4 C8                      RET      Z           ; Yes - Return
 2056 0DF5 FE2D                    CP       '-'         ; '-' ASCII ?
 2057 0DF7 C8                      RET      Z           ; Yes - Return
 2058 0DF8 14                      INC      D           ; Inc to flag positive 
 2059 0DF9 FE2B                    CP       '+'         ; '+' ASCII ?
 2060 0DFB C8                      RET      Z           ; Yes - Return
 2061 0DFC FEAC                    CP       ZPLUS       ; '+' token ?
 2062 0DFE C8                      RET      Z           ; Yes - Return
 2063 0DFF 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2064 0E00 C9                      RET                  ; Return "NZ"
 2065                   ;
 2066 0E01 F6           POR:       DB       0F6H        ; Flag "OR"
 2067 0E02 AF           PAND:      XOR      A           ; Flag "AND"
 2068 0E03 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2069 0E04 CDBB0C                  CALL     TSTNUM      ; Make sure it's a numb
 2070 0E07 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 2071 0E0A F1                      POP      AF          ; Restore "AND" / "OR" 
 2072 0E0B EB                      EX       DE,HL       ; <- Get last
 2073 0E0C C1                      POP      BC          ; <- value
 2074 0E0D E3                      EX       (SP),HL     ; <- from
 2075 0E0E EB                      EX       DE,HL       ; <- stack
 2076 0E0F CDDB16                  CALL     FPBCDE      ; Move last value to FP
 2077 0E12 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2078 0E13 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 2079 0E16 F1                      POP      AF          ; Restore "AND" / "OR" 
 2080 0E17 C1                      POP      BC          ; Get value
 2081 0E18 79                      LD       A,C         ; Get LSB
 2082 0E19 217210                  LD       HL,ACPASS   ; Address of save AC as
 2083 0E1C C2240E                  JP       NZ,POR1     ; Jump if OR
 2084 0E1F A3                      AND      E           ; "AND" LSBs
 2085 0E20 4F                      LD       C,A         ; Save LSB
 2086 0E21 78                      LD       A,B         ; Get MBS
 2087 0E22 A2                      AND      D           ; "AND" MSBs
 2088 0E23 E9                      JP       (HL)        ; Save AC as current (A
 2089                   ;
 2090 0E24 B3           POR1:      OR       E           ; "OR" LSBs
 2091 0E25 4F                      LD       C,A         ; Save LSB
 2092 0E26 78                      LD       A,B         ; Get MSB
 2093 0E27 B2                      OR       D           ; "OR" MSBs
 2094 0E28 E9                      JP       (HL)        ; Save AC as current (A
 2095                   ;
 2096 0E29 213B0E       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2097 0E2C 3AF280                  LD       A,(TYPE)    ; Get data type
 2098 0E2F 1F                      RRA                  ; Carry set = string
 2099 0E30 7A                      LD       A,D         ; Get last precedence v
 2100 0E31 17                      RLA                  ; Times 2 plus carry
 2101 0E32 5F                      LD       E,A         ; To E
 2102 0E33 1664                    LD       D,64H       ; Relational precedence
 2103 0E35 78                      LD       A,B         ; Get current precedenc
 2104 0E36 BA                      CP       D           ; Compare with last
 2105 0E37 D0                      RET      NC          ; Eval if last was rel'
 2106 0E38 C32A0D                  JP       STKTHS      ; Stack this one and ge
 2107                   ;
 2108 0E3B 3D0E         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2109 0E3D 79           CMPLG1:    LD       A,C         ; Get data type
 2110 0E3E B7                      OR       A
 2111 0E3F 1F                      RRA
 2112 0E40 C1                      POP      BC          ; Get last expression t
 2113 0E41 D1                      POP      DE
 2114 0E42 F5                      PUSH     AF          ; Save status
 2115 0E43 CDBD0C                  CALL     CHKTYP      ; Check that types matc
 2116 0E46 217F0E                  LD       HL,CMPRES   ; Result to comparison
 2117 0E49 E5                      PUSH     HL          ; Save for RETurn
 2118 0E4A CA1517                  JP       Z,CMPNUM    ; Compare values if num
 2119 0E4D AF                      XOR      A           ; Compare two strings
 2120 0E4E 32F280                  LD       (TYPE),A    ; Set type to numeric
 2121 0E51 D5                      PUSH     DE          ; Save string name
 2122 0E52 CDD412                  CALL     GSTRCU      ; Get current string
 2123 0E55 7E                      LD       A,(HL)      ; Get length of string
 2124 0E56 23                      INC      HL
 2125 0E57 23                      INC      HL
 2126 0E58 4E                      LD       C,(HL)      ; Get LSB of address
 2127 0E59 23                      INC      HL
 2128 0E5A 46                      LD       B,(HL)      ; Get MSB of address
 2129 0E5B D1                      POP      DE          ; Restore string name
 2130 0E5C C5                      PUSH     BC          ; Save address of strin
 2131 0E5D F5                      PUSH     AF          ; Save length of string
 2132 0E5E CDD812                  CALL     GSTRDE      ; Get second string
 2133 0E61 CDE916                  CALL     LOADFP      ; Get address of second
 2134 0E64 F1                      POP      AF          ; Restore length of str
 2135 0E65 57                      LD       D,A         ; Length to D
 2136 0E66 E1                      POP      HL          ; Restore address of st
 2137 0E67 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2138 0E68 B2                      OR       D           ; Bytes of string 1 to 
 2139 0E69 C8                      RET      Z           ; Exit if all bytes com
 2140 0E6A 7A                      LD       A,D         ; Get bytes of string 1
 2141 0E6B D601                    SUB      1
 2142 0E6D D8                      RET      C           ; Exit if end of string
 2143 0E6E AF                      XOR      A
 2144 0E6F BB                      CP       E           ; Bytes of string 2 to 
 2145 0E70 3C                      INC      A
 2146 0E71 D0                      RET      NC          ; Exit if end of string
 2147 0E72 15                      DEC      D           ; Count bytes in string
 2148 0E73 1D                      DEC      E           ; Count bytes in string
 2149 0E74 0A                      LD       A,(BC)      ; Byte in string 2
 2150 0E75 BE                      CP       (HL)        ; Compare to byte in st
 2151 0E76 23                      INC      HL          ; Move up string 1
 2152 0E77 03                      INC      BC          ; Move up string 2
 2153 0E78 CA670E                  JP       Z,CMPSTR    ; Same - Try next bytes
 2154 0E7B 3F                      CCF                  ; Flag difference (">" 
 2155 0E7C C3A516                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2156                   ;
 2157 0E7F 3C           CMPRES:    INC      A           ; Increment current val
 2158 0E80 8F                      ADC      A,A         ; Double plus carry
 2159 0E81 C1                      POP      BC          ; Get other value
 2160 0E82 A0                      AND      B           ; Combine them
 2161 0E83 C6FF                    ADD      A,-1        ; Carry set if differen
 2162 0E85 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2163 0E86 C3AC16                  JP       FLGREL      ; Set current value & c
 2164                   ;
 2165 0E89 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2166 0E8B CDCD0C                  CALL     EVAL1       ; Eval until precedence
 2167 0E8E CDBB0C                  CALL     TSTNUM      ; Make sure it's a numb
 2168 0E91 CDFD08                  CALL     DEINT       ; Get integer -32768 - 
 2169 0E94 7B                      LD       A,E         ; Get LSB
 2170 0E95 2F                      CPL                  ; Invert LSB
 2171 0E96 4F                      LD       C,A         ; Save "NOT" of LSB
 2172 0E97 7A                      LD       A,D         ; Get MSB
 2173 0E98 2F                      CPL                  ; Invert MSB
 2174 0E99 CD7210                  CALL     ACPASS      ; Save AC as current
 2175 0E9C C1                      POP      BC          ; Clean up stack
 2176 0E9D C3D90C                  JP       EVAL3       ; Continue evaluation
 2177                   ;
 2178 0EA0 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2179 0EA1 CD4B08                  CALL     GETCHR      ; Get next character
 2180 0EA4 C8                      RET      Z           ; End of DIM statement
 2181 0EA5 CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 2182 0EA8 2C                      DB       ','
 2183 0EA9 01A00E       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2184 0EAC C5                      PUSH     BC          ; Save on stack
 2185 0EAD F6                      DB       0F6H        ; Flag "Create" variabl
 2186 0EAE AF           GETVAR:    XOR      A           ; Find variable address
 2187 0EAF 32F180                  LD       (LCRFLG),A  ; Set locate / create f
 2188 0EB2 46                      LD       B,(HL)      ; Get First byte of nam
 2189 0EB3 CDE908       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2190 0EB6 DAF303                  JP       C,SNERR     ; ?SN Error if not a le
 2191 0EB9 AF                      XOR      A
 2192 0EBA 4F                      LD       C,A         ; Clear second byte of 
 2193 0EBB 32F280                  LD       (TYPE),A    ; Set type to numeric
 2194 0EBE CD4B08                  CALL     GETCHR      ; Get next character
 2195 0EC1 DACA0E                  JP       C,SVNAM2    ; Numeric - Save in nam
 2196 0EC4 CDE908                  CALL     CHKLTR      ; See if a letter
 2197 0EC7 DAD70E                  JP       C,CHARTY    ; Not a letter - Check 
 2198 0ECA 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2199 0ECB CD4B08       ENDNAM:    CALL     GETCHR      ; Get next character
 2200 0ECE DACB0E                  JP       C,ENDNAM    ; Numeric - Get another
 2201 0ED1 CDE908                  CALL     CHKLTR      ; See if a letter
 2202 0ED4 D2CB0E                  JP       NC,ENDNAM   ; Letter - Get another
 2203 0ED7 D624         CHARTY:    SUB      '$'         ; String variable?
 2204 0ED9 C2E60E                  JP       NZ,NOTSTR   ; No - Numeric variable
 2205 0EDC 3C                      INC      A           ; A = 1 (string type)
 2206 0EDD 32F280                  LD       (TYPE),A    ; Set type to string
 2207 0EE0 0F                      RRCA                 ; A = 80H , Flag for st
 2208 0EE1 81                      ADD      A,C         ; 2nd byte of name has 
 2209 0EE2 4F                      LD       C,A         ; Resave second byte on
 2210 0EE3 CD4B08                  CALL     GETCHR      ; Get next character
 2211 0EE6 3A1081       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2212 0EE9 3D                      DEC      A
 2213 0EEA CA930F                  JP       Z,ARLDSV    ; Yes - Get array name
 2214 0EED F2F60E                  JP       P,NSCFOR    ; No array with "FOR" o
 2215 0EF0 7E                      LD       A,(HL)      ; Get byte again
 2216 0EF1 D628                    SUB      '('         ; Subscripted variable?
 2217 0EF3 CA6B0F                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2218                   ;
 2219 0EF6 AF           NSCFOR:    XOR      A           ; Simple variable
 2220 0EF7 321081                  LD       (FORFLG),A  ; Clear "FOR" flag
 2221 0EFA E5                      PUSH     HL          ; Save code string addr
 2222 0EFB 50                      LD       D,B         ; DE = Variable name to
 2223 0EFC 59                      LD       E,C
 2224 0EFD 2A2381                  LD       HL,(FNRGNM) ; FN argument name
 2225 0F00 CDBB06                  CALL     CPDEHL      ; Is it the FN argument
 2226 0F03 112581                  LD       DE,FNARG    ; Point to argument val
 2227 0F06 CADB15                  JP       Z,POPHRT    ; Yes - Return FN argum
 2228 0F09 2A1D81                  LD       HL,(VAREND) ; End of variables
 2229 0F0C EB                      EX       DE,HL       ; Address of end of sea
 2230 0F0D 2A1B81                  LD       HL,(PROGND) ; Start of variables ad
 2231 0F10 CDBB06       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2232 0F13 CA290F                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2233 0F16 79                      LD       A,C         ; Get second byte of na
 2234 0F17 96                      SUB      (HL)        ; Compare with name in 
 2235 0F18 23                      INC      HL          ; Move on to first byte
 2236 0F19 C21E0F                  JP       NZ,FNTHR    ; Different - Find anot
 2237 0F1C 78                      LD       A,B         ; Get first byte of nam
 2238 0F1D 96                      SUB      (HL)        ; Compare with name in 
 2239 0F1E 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2240 0F1F CA5D0F                  JP       Z,RETADR    ; Found - Return addres
 2241 0F22 23                      INC      HL          ; <- Skip
 2242 0F23 23                      INC      HL          ; <- over
 2243 0F24 23                      INC      HL          ; <- F.P.
 2244 0F25 23                      INC      HL          ; <- value
 2245 0F26 C3100F                  JP       FNDVAR      ; Keep looking
 2246                   ;
 2247 0F29 E1           CFEVAL:    POP      HL          ; Restore code string a
 2248 0F2A E3                      EX       (SP),HL     ; Get return address
 2249 0F2B D5                      PUSH     DE          ; Save address of varia
 2250 0F2C 11AB0D                  LD       DE,FRMEVL   ; Return address in EVA
 2251 0F2F CDBB06                  CALL     CPDEHL      ; Called from EVAL ?
 2252 0F32 D1                      POP      DE          ; Restore address of va
 2253 0F33 CA600F                  JP       Z,RETNUL    ; Yes - Return null var
 2254 0F36 E3                      EX       (SP),HL     ; Put back return
 2255 0F37 E5                      PUSH     HL          ; Save code string addr
 2256 0F38 C5                      PUSH     BC          ; Save variable name
 2257 0F39 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2258 0F3C 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2259 0F3F E5                      PUSH     HL          ; Save end of arrays
 2260 0F40 09                      ADD      HL,BC       ; Move up 6 bytes
 2261 0F41 C1                      POP      BC          ; Source address in BC
 2262 0F42 E5                      PUSH     HL          ; Save new end address
 2263 0F43 CDBF03                  CALL     MOVUP       ; Move arrays up
 2264 0F46 E1                      POP      HL          ; Restore new end addre
 2265 0F47 221F81                  LD       (ARREND),HL ; Set new end address
 2266 0F4A 60                      LD       H,B         ; End of variables to H
 2267 0F4B 69                      LD       L,C
 2268 0F4C 221D81                  LD       (VAREND),HL ; Set new end address
 2269                   ;
 2270 0F4F 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2271 0F50 3600                    LD       (HL),0      ; Zero byte in variable
 2272 0F52 CDBB06                  CALL     CPDEHL      ; Done them all?
 2273 0F55 C24F0F                  JP       NZ,ZEROLP   ; No - Keep on going
 2274 0F58 D1                      POP      DE          ; Get variable name
 2275 0F59 73                      LD       (HL),E      ; Store second characte
 2276 0F5A 23                      INC      HL
 2277 0F5B 72                      LD       (HL),D      ; Store first character
 2278 0F5C 23                      INC      HL
 2279 0F5D EB           RETADR:    EX       DE,HL       ; Address of variable i
 2280 0F5E E1                      POP      HL          ; Restore code string a
 2281 0F5F C9                      RET
 2282                   ;
 2283 0F60 322C81       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2284 0F63 218F03                  LD       HL,ZERBYT   ; Also set a null strin
 2285 0F66 222981                  LD       (FPREG),HL  ; Save for EVAL
 2286 0F69 E1                      POP      HL          ; Restore code string a
 2287 0F6A C9                      RET
 2288                   ;
 2289 0F6B E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2290 0F6C 2AF180                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2291 0F6F E3                      EX       (SP),HL     ; Save and get code str
 2292 0F70 57                      LD       D,A         ; Zero number of dimens
 2293 0F71 D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2294 0F72 C5                      PUSH     BC          ; Save array name
 2295 0F73 CDF108                  CALL     FPSINT      ; Get subscript (0-3276
 2296 0F76 C1                      POP      BC          ; Restore array name
 2297 0F77 F1                      POP      AF          ; Get number of dimensi
 2298 0F78 EB                      EX       DE,HL
 2299 0F79 E3                      EX       (SP),HL     ; Save subscript value
 2300 0F7A E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2301 0F7B EB                      EX       DE,HL
 2302 0F7C 3C                      INC      A           ; Count dimensions
 2303 0F7D 57                      LD       D,A         ; Save in D
 2304 0F7E 7E                      LD       A,(HL)      ; Get next byte in code
 2305 0F7F FE2C                    CP       ','         ; Comma (more to come)?
 2306 0F81 CA710F                  JP       Z,SCPTLP    ; Yes - More subscripts
 2307 0F84 CDC106                  CALL     CHKSYN      ; Make sure ")" follows
 2308 0F87 29                      DB       ")"
 2309 0F88 221581                  LD       (NXTOPR),HL ; Save code string addr
 2310 0F8B E1                      POP      HL          ; Get LCRFLG and TYPE
 2311 0F8C 22F180                  LD       (LCRFLG),HL ; Restore Locate/create
 2312 0F8F 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2313 0F91 D5                      PUSH     DE          ; Save number of dimens
 2314 0F92 11                      DB       11H         ; Skip "PUSH HL" and "P
 2315                   ;
 2316 0F93 E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2317 0F94 F5                      PUSH     AF          ; A = 00 , Flags set = 
 2318 0F95 2A1D81                  LD       HL,(VAREND) ; Start of arrays
 2319 0F98 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2320 0F99 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2321 0F9A EB                      EX       DE,HL
 2322 0F9B 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2323 0F9E EB                      EX       DE,HL       ; Current array pointer
 2324 0F9F CDBB06                  CALL     CPDEHL      ; End of arrays found?
 2325 0FA2 CACB0F                  JP       Z,CREARY    ; Yes - Create array
 2326 0FA5 7E                      LD       A,(HL)      ; Get second byte of na
 2327 0FA6 B9                      CP       C           ; Compare with name giv
 2328 0FA7 23                      INC      HL          ; Move on
 2329 0FA8 C2AD0F                  JP       NZ,NXTARY   ; Different - Find next
 2330 0FAB 7E                      LD       A,(HL)      ; Get first byte of nam
 2331 0FAC B8                      CP       B           ; Compare with name giv
 2332 0FAD 23           NXTARY:    INC      HL          ; Move on
 2333 0FAE 5E                      LD       E,(HL)      ; Get LSB of next array
 2334 0FAF 23                      INC      HL
 2335 0FB0 56                      LD       D,(HL)      ; Get MSB of next array
 2336 0FB1 23                      INC      HL
 2337 0FB2 C2990F                  JP       NZ,FNDARY   ; Not found - Keep look
 2338 0FB5 3AF180                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2339 0FB8 B7                      OR       A
 2340 0FB9 C2FC03                  JP       NZ,DDERR    ; Create - ?DD Error
 2341 0FBC F1                      POP      AF          ; Locate - Get number o
 2342 0FBD 44                      LD       B,H         ; BC Points to array di
 2343 0FBE 4D                      LD       C,L
 2344 0FBF CADB15                  JP       Z,POPHRT    ; Jump if array load/sa
 2345 0FC2 96                      SUB      (HL)        ; Same number of dimens
 2346 0FC3 CA2910                  JP       Z,FINDEL    ; Yes - Find element
 2347 0FC6 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2348 0FC8 C30704                  JP       ERROR       ; Output error
 2349                   ;
 2350 0FCB 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2351 0FCE F1                      POP      AF          ; Array to save or 0 di
 2352 0FCF CA1209                  JP       Z,FCERR     ; Yes - ?FC Error
 2353 0FD2 71                      LD       (HL),C      ; Save second byte of n
 2354 0FD3 23                      INC      HL
 2355 0FD4 70                      LD       (HL),B      ; Save first byte of na
 2356 0FD5 23                      INC      HL
 2357 0FD6 4F                      LD       C,A         ; Number of dimensions 
 2358 0FD7 CDD003                  CALL     CHKSTK      ; Check if enough memor
 2359 0FDA 23                      INC      HL          ; Point to number of di
 2360 0FDB 23                      INC      HL
 2361 0FDC 220A81                  LD       (CUROPR),HL ; Save address of point
 2362 0FDF 71                      LD       (HL),C      ; Set number of dimensi
 2363 0FE0 23                      INC      HL
 2364 0FE1 3AF180                  LD       A,(LCRFLG)  ; Locate of Create?
 2365 0FE4 17                      RLA                  ; Carry set = Create
 2366 0FE5 79                      LD       A,C         ; Get number of dimensi
 2367 0FE6 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2368 0FE9 D2EE0F                  JP       NC,DEFSIZ   ; Locate - Set default 
 2369 0FEC C1                      POP      BC          ; Get specified dimensi
 2370 0FED 03                      INC      BC          ; Include zero element
 2371 0FEE 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2372 0FEF 23                      INC      HL
 2373 0FF0 70                      LD       (HL),B      ; Save MSB of dimension
 2374 0FF1 23                      INC      HL
 2375 0FF2 F5                      PUSH     AF          ; Save num' of dim'ns a
 2376 0FF3 E5                      PUSH     HL          ; Save address of dim'n
 2377 0FF4 CD8617                  CALL     MLDEBC      ; Multiply DE by BC to 
 2378 0FF7 EB                      EX       DE,HL       ; amount of mem needed 
 2379 0FF8 E1                      POP      HL          ; Restore address of di
 2380 0FF9 F1                      POP      AF          ; Restore number of dim
 2381 0FFA 3D                      DEC      A           ; Count them
 2382 0FFB C2E60F                  JP       NZ,CRARLP   ; Do next dimension if 
 2383 0FFE F5                      PUSH     AF          ; Save locate/create fl
 2384 0FFF 42                      LD       B,D         ; MSB of memory needed
 2385 1000 4B                      LD       C,E         ; LSB of memory needed
 2386 1001 EB                      EX       DE,HL
 2387 1002 19                      ADD      HL,DE       ; Add bytes to array st
 2388 1003 DAE803                  JP       C,OMERR     ; Too big - Error
 2389 1006 CDD903                  CALL     ENFMEM      ; See if enough memory
 2390 1009 221F81                  LD       (ARREND),HL ; Save new end of array
 2391                   ;
 2392 100C 2B           ZERARY:    DEC      HL          ; Back through array da
 2393 100D 3600                    LD       (HL),0      ; Set array element to 
 2394 100F CDBB06                  CALL     CPDEHL      ; All elements zeroed?
 2395 1012 C20C10                  JP       NZ,ZERARY   ; No - Keep on going
 2396 1015 03                      INC      BC          ; Number of bytes + 1
 2397 1016 57                      LD       D,A         ; A=0
 2398 1017 2A0A81                  LD       HL,(CUROPR) ; Get address of array
 2399 101A 5E                      LD       E,(HL)      ; Number of dimensions
 2400 101B EB                      EX       DE,HL       ; To HL
 2401 101C 29                      ADD      HL,HL       ; Two bytes per dimensi
 2402 101D 09                      ADD      HL,BC       ; Add number of bytes
 2403 101E EB                      EX       DE,HL       ; Bytes needed to DE
 2404 101F 2B                      DEC      HL
 2405 1020 2B                      DEC      HL
 2406 1021 73                      LD       (HL),E      ; Save LSB of bytes nee
 2407 1022 23                      INC      HL
 2408 1023 72                      LD       (HL),D      ; Save MSB of bytes nee
 2409 1024 23                      INC      HL
 2410 1025 F1                      POP      AF          ; Locate / Create?
 2411 1026 DA4D10                  JP       C,ENDDIM    ; A is 0 , End if creat
 2412 1029 47           FINDEL:    LD       B,A         ; Find array element
 2413 102A 4F                      LD       C,A
 2414 102B 7E                      LD       A,(HL)      ; Number of dimensions
 2415 102C 23                      INC      HL
 2416 102D 16                      DB       16H         ; Skip "POP HL"
 2417 102E E1           FNDELP:    POP      HL          ; Address of next dim' 
 2418 102F 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2419 1030 23                      INC      HL
 2420 1031 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2421 1032 23                      INC      HL
 2422 1033 E3                      EX       (SP),HL     ; Save address - Get in
 2423 1034 F5                      PUSH     AF          ; Save number of dim'ns
 2424 1035 CDBB06                  CALL     CPDEHL      ; Dimension too large?
 2425 1038 D2C60F                  JP       NC,BSERR    ; Yes - ?BS Error
 2426 103B E5                      PUSH     HL          ; Save index
 2427 103C CD8617                  CALL     MLDEBC      ; Multiply previous by 
 2428 103F D1                      POP      DE          ; Index supplied to DE
 2429 1040 19                      ADD      HL,DE       ; Add index to pointer
 2430 1041 F1                      POP      AF          ; Number of dimensions
 2431 1042 3D                      DEC      A           ; Count them
 2432 1043 44                      LD       B,H         ; MSB of pointer
 2433 1044 4D                      LD       C,L         ; LSB of pointer
 2434 1045 C22E10                  JP       NZ,FNDELP   ; More - Keep going
 2435 1048 29                      ADD      HL,HL       ; 4 Bytes per element
 2436 1049 29                      ADD      HL,HL
 2437 104A C1                      POP      BC          ; Start of array
 2438 104B 09                      ADD      HL,BC       ; Point to element
 2439 104C EB                      EX       DE,HL       ; Address of element to
 2440 104D 2A1581       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2441 1050 C9                      RET
 2442                   ;
 2443 1051 2A1F81       FRE:       LD       HL,(ARREND) ; Start of free memory
 2444 1054 EB                      EX       DE,HL       ; To DE
 2445 1055 210000                  LD       HL,0        ; End of free memory
 2446 1058 39                      ADD      HL,SP       ; Current stack value
 2447 1059 3AF280                  LD       A,(TYPE)    ; Dummy argument type
 2448 105C B7                      OR       A
 2449 105D CA6D10                  JP       Z,FRENUM    ; Numeric - Free variab
 2450 1060 CDD412                  CALL     GSTRCU      ; Current string to poo
 2451 1063 CDD411                  CALL     GARBGE      ; Garbage collection
 2452 1066 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2453 1069 EB                      EX       DE,HL       ; To DE
 2454 106A 2A0881                  LD       HL,(STRBOT) ; Bottom of string spac
 2455 106D 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2456 106E 93                      SUB      E           ; Subtract LSB of begin
 2457 106F 4F                      LD       C,A         ; Save difference if C
 2458 1070 7C                      LD       A,H         ; Get MSB of end
 2459 1071 9A                      SBC      A,D         ; Subtract MSB of begin
 2460 1072 41           ACPASS:    LD       B,C         ; Return integer AC
 2461 1073 50           ABPASS:    LD       D,B         ; Return integer AB
 2462 1074 1E00                    LD       E,0
 2463 1076 21F280                  LD       HL,TYPE     ; Point to type
 2464 1079 73                      LD       (HL),E      ; Set type to numeric
 2465 107A 0690                    LD       B,80H+16    ; 16 bit integer
 2466 107C C3B116                  JP       RETINT      ; Return the integr
 2467                   ;
 2468 107F 3AF080       POS:       LD       A,(CURPOS)  ; Get cursor position
 2469 1082 47           PASSA:     LD       B,A         ; Put A into AB
 2470 1083 AF                      XOR      A           ; Zero A
 2471 1084 C37310                  JP       ABPASS      ; Return integer AB
 2472                   ;
 2473 1087 CD0A11       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2474 108A CDFC10                  CALL     IDTEST      ; Test for illegal dire
 2475 108D 01E209                  LD       BC,DATA     ; To get next statement
 2476 1090 C5                      PUSH     BC          ; Save address for RETu
 2477 1091 D5                      PUSH     DE          ; Save address of funct
 2478 1092 CDC106                  CALL     CHKSYN      ; Make sure "(" follows
 2479 1095 28                      DB       "("
 2480 1096 CDAE0E                  CALL     GETVAR      ; Get argument variable
 2481 1099 E5                      PUSH     HL          ; Save code string addr
 2482 109A EB                      EX       DE,HL       ; Argument address to H
 2483 109B 2B                      DEC      HL
 2484 109C 56                      LD       D,(HL)      ; Get first byte of arg
 2485 109D 2B                      DEC      HL
 2486 109E 5E                      LD       E,(HL)      ; Get second byte of ar
 2487 109F E1                      POP      HL          ; Restore code string a
 2488 10A0 CDBB0C                  CALL     TSTNUM      ; Make sure numeric arg
 2489 10A3 CDC106                  CALL     CHKSYN      ; Make sure ")" follows
 2490 10A6 29                      DB       ")"
 2491 10A7 CDC106                  CALL     CHKSYN      ; Make sure "=" follows
 2492 10AA B4                      DB       ZEQUAL      ; "=" token
 2493 10AB 44                      LD       B,H         ; Code string address t
 2494 10AC 4D                      LD       C,L
 2495 10AD E3                      EX       (SP),HL     ; Save code str , Get F
 2496 10AE 71                      LD       (HL),C      ; Save LSB of FN code s
 2497 10AF 23                      INC      HL
 2498 10B0 70                      LD       (HL),B      ; Save MSB of FN code s
 2499 10B1 C34911                  JP       SVSTAD      ; Save address and do f
 2500                   ;
 2501 10B4 CD0A11       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2502 10B7 D5                      PUSH     DE          ; Save function pointer
 2503 10B8 CD8F0D                  CALL     EVLPAR      ; Evaluate expression i
 2504 10BB CDBB0C                  CALL     TSTNUM      ; Make sure numeric res
 2505 10BE E3                      EX       (SP),HL     ; Save code str , Get F
 2506 10BF 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2507 10C0 23                      INC      HL
 2508 10C1 56                      LD       D,(HL)      ; Get MSB of FN code st
 2509 10C2 23                      INC      HL
 2510 10C3 7A                      LD       A,D         ; And function DEFined?
 2511 10C4 B3                      OR       E
 2512 10C5 CAFF03                  JP       Z,UFERR     ; No - ?UF Error
 2513 10C8 7E                      LD       A,(HL)      ; Get LSB of argument a
 2514 10C9 23                      INC      HL
 2515 10CA 66                      LD       H,(HL)      ; Get MSB of argument a
 2516 10CB 6F                      LD       L,A         ; HL = Arg variable add
 2517 10CC E5                      PUSH     HL          ; Save it
 2518 10CD 2A2381                  LD       HL,(FNRGNM) ; Get old argument name
 2519 10D0 E3                      EX       (SP),HL     ;        ; Save old , G
 2520 10D1 222381                  LD       (FNRGNM),HL ; Set new argument name
 2521 10D4 2A2781                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2522 10D7 E5                      PUSH     HL          ; Save it
 2523 10D8 2A2581                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2524 10DB E5                      PUSH     HL          ; Save it
 2525 10DC 212581                  LD       HL,FNARG    ; HL = Value of argumen
 2526 10DF D5                      PUSH     DE          ; Save FN code string a
 2527 10E0 CDF216                  CALL     FPTHL       ; Move FPREG to argumen
 2528 10E3 E1                      POP      HL          ; Get FN code string ad
 2529 10E4 CDB80C                  CALL     GETNUM      ; Get value from functi
 2530 10E7 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2531 10E8 CD4B08                  CALL     GETCHR      ; Get next character
 2532 10EB C2F303                  JP       NZ,SNERR    ; Bad character in FN -
 2533 10EE E1                      POP      HL          ; Get MSB,EXP of old ar
 2534 10EF 222581                  LD       (FNARG),HL  ; Restore it
 2535 10F2 E1                      POP      HL          ; Get LSB,NLSB of old a
 2536 10F3 222781                  LD       (FNARG+2),HL ; Restore it
 2537 10F6 E1                      POP      HL          ; Get name of old arg
 2538 10F7 222381                  LD       (FNRGNM),HL ; Restore it
 2539 10FA E1                      POP      HL          ; Restore code string a
 2540 10FB C9                      RET
 2541                   ;
 2542 10FC E5           IDTEST:    PUSH     HL          ; Save code string addr
 2543 10FD 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 2544 1100 23                      INC      HL          ; -1 means direct state
 2545 1101 7C                      LD       A,H
 2546 1102 B5                      OR       L
 2547 1103 E1                      POP      HL          ; Restore code string a
 2548 1104 C0                      RET      NZ          ; Return if in program
 2549 1105 1E16                    LD       E,ID        ; ?ID Error
 2550 1107 C30704                  JP       ERROR
 2551                   ;
 2552 110A CDC106       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2553 110D A7                      DB       ZFN         ; "FN" token
 2554 110E 3E80                    LD       A,80H
 2555 1110 321081                  LD       (FORFLG),A  ; Flag FN name to find
 2556 1113 B6                      OR       (HL)        ; FN name has bit 7 set
 2557 1114 47                      LD       B,A         ; in first byte of name
 2558 1115 CDB30E                  CALL     GTFNAM      ; Get FN name
 2559 1118 C3BB0C                  JP       TSTNUM      ; Make sure numeric fun
 2560                   ;
 2561 111B CDBB0C       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2562 111E CD3F18                  CALL     NUMASC      ; Turn number into text
 2563 1121 CD4F11       STR1:      CALL     CRTST       ; Create string entry f
 2564 1124 CDD412                  CALL     GSTRCU      ; Current string to poo
 2565 1127 012F13                  LD       BC,TOPOOL   ; Save in string pool
 2566 112A C5                      PUSH     BC          ; Save address on stack
 2567                   ;
 2568 112B 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2569 112C 23                      INC      HL
 2570 112D 23                      INC      HL
 2571 112E E5                      PUSH     HL          ; Save pointer to strin
 2572 112F CDAA11                  CALL     TESTR       ; See if enough string 
 2573 1132 E1                      POP      HL          ; Restore pointer to st
 2574 1133 4E                      LD       C,(HL)      ; Get LSB of address
 2575 1134 23                      INC      HL
 2576 1135 46                      LD       B,(HL)      ; Get MSB of address
 2577 1136 CD4311                  CALL     CRTMST      ; Create string entry
 2578 1139 E5                      PUSH     HL          ; Save pointer to MSB o
 2579 113A 6F                      LD       L,A         ; Length of string
 2580 113B CDC712                  CALL     TOSTRA      ; Move to string area
 2581 113E D1                      POP      DE          ; Restore pointer to MS
 2582 113F C9                      RET
 2583                   ;
 2584 1140 CDAA11       MKTMST:    CALL     TESTR       ; See if enough string 
 2585 1143 210481       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2586 1146 E5                      PUSH     HL          ; Save it
 2587 1147 77                      LD       (HL),A      ; Save length of string
 2588 1148 23                      INC      HL
 2589 1149 23           SVSTAD:    INC      HL
 2590 114A 73                      LD       (HL),E      ; Save LSB of address
 2591 114B 23                      INC      HL
 2592 114C 72                      LD       (HL),D      ; Save MSB of address
 2593 114D E1                      POP      HL          ; Restore pointer
 2594 114E C9                      RET
 2595                   ;
 2596 114F 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2597 1150 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2598 1152 50                      LD       D,B         ; Quote to D
 2599 1153 E5           DTSTR:     PUSH     HL          ; Save start
 2600 1154 0EFF                    LD       C,-1        ; Set counter to -1
 2601 1156 23           QTSTLP:    INC      HL          ; Move on
 2602 1157 7E                      LD       A,(HL)      ; Get byte
 2603 1158 0C                      INC      C           ; Count bytes
 2604 1159 B7                      OR       A           ; End of line?
 2605 115A CA6511                  JP       Z,CRTSTE    ; Yes - Create string e
 2606 115D BA                      CP       D           ; Terminator D found?
 2607 115E CA6511                  JP       Z,CRTSTE    ; Yes - Create string e
 2608 1161 B8                      CP       B           ; Terminator B found?
 2609 1162 C25611                  JP       NZ,QTSTLP   ; No - Keep looking
 2610 1165 FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2611 1167 CC4B08                  CALL     Z,GETCHR    ; Yes - Get next charac
 2612 116A E3                      EX       (SP),HL     ; Starting quote
 2613 116B 23                      INC      HL          ; First byte of string
 2614 116C EB                      EX       DE,HL       ; To DE
 2615 116D 79                      LD       A,C         ; Get length
 2616 116E CD4311                  CALL     CRTMST      ; Create string entry
 2617 1171 110481       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2618 1174 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2619 1177 222981                  LD       (FPREG),HL  ; Save address of strin
 2620 117A 3E01                    LD       A,1
 2621 117C 32F280                  LD       (TYPE),A    ; Set type to string
 2622 117F CDF516                  CALL     DETHL4      ; Move string to pool
 2623 1182 CDBB06                  CALL     CPDEHL      ; Out of string pool?
 2624 1185 22F680                  LD       (TMSTPT),HL ; Save new pointer
 2625 1188 E1                      POP      HL          ; Restore code string a
 2626 1189 7E                      LD       A,(HL)      ; Get next code byte
 2627 118A C0                      RET      NZ          ; Return if pool OK
 2628 118B 1E1E                    LD       E,ST        ; ?ST Error
 2629 118D C30704                  JP       ERROR       ; String pool overflow
 2630                   ;
 2631 1190 23           PRNUMS:    INC      HL          ; Skip leading space
 2632 1191 CD4F11       PRS:       CALL     CRTST       ; Create string entry f
 2633 1194 CDD412       PRS1:      CALL     GSTRCU      ; Current string to poo
 2634 1197 CDE916                  CALL     LOADFP      ; Move string block to 
 2635 119A 1C                      INC      E           ; Length + 1
 2636 119B 1D           PRSLP:     DEC      E           ; Count characters
 2637 119C C8                      RET      Z           ; End of string
 2638 119D 0A                      LD       A,(BC)      ; Get byte to output
 2639 119E CDCC06                  CALL     OUTC        ; Output character in A
 2640 11A1 FE0D                    CP       CR          ; Return?
 2641 11A3 CCFD0A                  CALL     Z,DONULL    ; Yes - Do nulls
 2642 11A6 03                      INC      BC          ; Next byte in string
 2643 11A7 C39B11                  JP       PRSLP       ; More characters to ou
 2644                   ;
 2645 11AA B7           TESTR:     OR       A           ; Test if enough room
 2646 11AB 0E                      DB       0EH         ; No garbage collection
 2647 11AC F1           GRBDON:    POP      AF          ; Garbage collection do
 2648 11AD F5                      PUSH     AF          ; Save status
 2649 11AE 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2650 11B1 EB                      EX       DE,HL       ; To DE
 2651 11B2 2A0881                  LD       HL,(STRBOT) ; Bottom of string area
 2652 11B5 2F                      CPL                  ; Negate length (Top do
 2653 11B6 4F                      LD       C,A         ; -Length to BC
 2654 11B7 06FF                    LD       B,-1        ; BC = -ve length of st
 2655 11B9 09                      ADD      HL,BC       ; Add to bottom of spac
 2656 11BA 23                      INC      HL          ; Plus one for 2's comp
 2657 11BB CDBB06                  CALL     CPDEHL      ; Below string RAM area
 2658 11BE DAC811                  JP       C,TESTOS    ; Tidy up if not done e
 2659 11C1 220881                  LD       (STRBOT),HL ; Save new bottom of ar
 2660 11C4 23                      INC      HL          ; Point to first byte o
 2661 11C5 EB                      EX       DE,HL       ; Address to DE
 2662 11C6 F1           POPAF:     POP      AF          ; Throw away status pus
 2663 11C7 C9                      RET
 2664                   ;
 2665 11C8 F1           TESTOS:    POP      AF          ; Garbage collect been 
 2666 11C9 1E1A                    LD       E,OS        ; ?OS Error
 2667 11CB CA0704                  JP       Z,ERROR     ; Yes - Not enough stri
 2668 11CE BF                      CP       A           ; Flag garbage collect 
 2669 11CF F5                      PUSH     AF          ; Save status
 2670 11D0 01AC11                  LD       BC,GRBDON   ; Garbage collection do
 2671 11D3 C5                      PUSH     BC          ; Save for RETurn
 2672 11D4 2AF480       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2673 11D7 220881       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2674 11DA 210000                  LD       HL,0
 2675 11DD E5                      PUSH     HL          ; Flag no string found
 2676 11DE 2A9F80                  LD       HL,(STRSPC) ; Get bottom of string 
 2677 11E1 E5                      PUSH     HL          ; Save bottom of string
 2678 11E2 21F880                  LD       HL,TMSTPL   ; Temporary string pool
 2679 11E5 EB           GRBLP:     EX       DE,HL
 2680 11E6 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2681 11E9 EB                      EX       DE,HL
 2682 11EA CDBB06                  CALL     CPDEHL      ; Temporary string pool
 2683 11ED 01E511                  LD       BC,GRBLP    ; Loop until string poo
 2684 11F0 C23912                  JP       NZ,STPOOL   ; No - See if in string
 2685 11F3 2A1B81                  LD       HL,(PROGND) ; Start of simple varia
 2686 11F6 EB           SMPVAR:    EX       DE,HL
 2687 11F7 2A1D81                  LD       HL,(VAREND) ; End of simple variabl
 2688 11FA EB                      EX       DE,HL
 2689 11FB CDBB06                  CALL     CPDEHL      ; All simple strings do
 2690 11FE CA0C12                  JP       Z,ARRLP     ; Yes - Do string array
 2691 1201 7E                      LD       A,(HL)      ; Get type of variable
 2692 1202 23                      INC      HL
 2693 1203 23                      INC      HL
 2694 1204 B7                      OR       A           ; "S" flag set if strin
 2695 1205 CD3C12                  CALL     STRADD      ; See if string in stri
 2696 1208 C3F611                  JP       SMPVAR      ; Loop until simple one
 2697                   ;
 2698 120B C1           GNXARY:    POP      BC          ; Scrap address of this
 2699 120C EB           ARRLP:     EX       DE,HL
 2700 120D 2A1F81                  LD       HL,(ARREND) ; End of string arrays
 2701 1210 EB                      EX       DE,HL
 2702 1211 CDBB06                  CALL     CPDEHL      ; All string arrays don
 2703 1214 CA6212                  JP       Z,SCNEND    ; Yes - Move string if 
 2704 1217 CDE916                  CALL     LOADFP      ; Get array name to BCD
 2705 121A 7B                      LD       A,E         ; Get type of array
 2706 121B E5                      PUSH     HL          ; Save address of num o
 2707 121C 09                      ADD      HL,BC       ; Start of next array
 2708 121D B7                      OR       A           ; Test type of array
 2709 121E F20B12                  JP       P,GNXARY    ; Numeric array - Ignor
 2710 1221 220A81                  LD       (CUROPR),HL ; Save address of next 
 2711 1224 E1                      POP      HL          ; Get address of num of
 2712 1225 4E                      LD       C,(HL)      ; BC = Number of dimens
 2713 1226 0600                    LD       B,0
 2714 1228 09                      ADD      HL,BC       ; Two bytes per dimensi
 2715 1229 09                      ADD      HL,BC
 2716 122A 23                      INC      HL          ; Plus one for number o
 2717 122B EB           GRBARY:    EX       DE,HL
 2718 122C 2A0A81                  LD       HL,(CUROPR) ; Get address of next a
 2719 122F EB                      EX       DE,HL
 2720 1230 CDBB06                  CALL     CPDEHL      ; Is this array finishe
 2721 1233 CA0C12                  JP       Z,ARRLP     ; Yes - Get next one
 2722 1236 012B12                  LD       BC,GRBARY   ; Loop until array all 
 2723 1239 C5           STPOOL:    PUSH     BC          ; Save return address
 2724 123A F680                    OR       80H         ; Flag string type
 2725 123C 7E           STRADD:    LD       A,(HL)      ; Get string length
 2726 123D 23                      INC      HL
 2727 123E 23                      INC      HL
 2728 123F 5E                      LD       E,(HL)      ; Get LSB of string add
 2729 1240 23                      INC      HL
 2730 1241 56                      LD       D,(HL)      ; Get MSB of string add
 2731 1242 23                      INC      HL
 2732 1243 F0                      RET      P           ; Not a string - Return
 2733 1244 B7                      OR       A           ; Set flags on string l
 2734 1245 C8                      RET      Z           ; Null string - Return
 2735 1246 44                      LD       B,H         ; Save variable pointer
 2736 1247 4D                      LD       C,L
 2737 1248 2A0881                  LD       HL,(STRBOT) ; Bottom of new area
 2738 124B CDBB06                  CALL     CPDEHL      ; String been done?
 2739 124E 60                      LD       H,B         ; Restore variable poin
 2740 124F 69                      LD       L,C
 2741 1250 D8                      RET      C           ; String done - Ignore
 2742 1251 E1                      POP      HL          ; Return address
 2743 1252 E3                      EX       (SP),HL     ; Lowest available stri
 2744 1253 CDBB06                  CALL     CPDEHL      ; String within string 
 2745 1256 E3                      EX       (SP),HL     ; Lowest available stri
 2746 1257 E5                      PUSH     HL          ; Re-save return addres
 2747 1258 60                      LD       H,B         ; Restore variable poin
 2748 1259 69                      LD       L,C
 2749 125A D0                      RET      NC          ; Outside string area -
 2750 125B C1                      POP      BC          ; Get return , Throw 2 
 2751 125C F1                      POP      AF          ;
 2752 125D F1                      POP      AF          ;
 2753 125E E5                      PUSH     HL          ; Save variable pointer
 2754 125F D5                      PUSH     DE          ; Save address of curre
 2755 1260 C5                      PUSH     BC          ; Put back return addre
 2756 1261 C9                      RET                  ; Go to it
 2757                   ;
 2758 1262 D1           SCNEND:    POP      DE          ; Addresses of strings
 2759 1263 E1                      POP      HL          ;
 2760 1264 7D                      LD       A,L         ; HL = 0 if no more to 
 2761 1265 B4                      OR       H
 2762 1266 C8                      RET      Z           ; No more to do - Retur
 2763 1267 2B                      DEC      HL
 2764 1268 46                      LD       B,(HL)      ; MSB of address of str
 2765 1269 2B                      DEC      HL
 2766 126A 4E                      LD       C,(HL)      ; LSB of address of str
 2767 126B E5                      PUSH     HL          ; Save variable address
 2768 126C 2B                      DEC      HL
 2769 126D 2B                      DEC      HL
 2770 126E 6E                      LD       L,(HL)      ; HL = Length of string
 2771 126F 2600                    LD       H,0
 2772 1271 09                      ADD      HL,BC       ; Address of end of str
 2773 1272 50                      LD       D,B         ; String address to DE
 2774 1273 59                      LD       E,C
 2775 1274 2B                      DEC      HL          ; Last byte in string
 2776 1275 44                      LD       B,H         ; Address to BC
 2777 1276 4D                      LD       C,L
 2778 1277 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2779 127A CDC203                  CALL     MOVSTR      ; Move string to new ad
 2780 127D E1                      POP      HL          ; Restore variable addr
 2781 127E 71                      LD       (HL),C      ; Save new LSB of addre
 2782 127F 23                      INC      HL
 2783 1280 70                      LD       (HL),B      ; Save new MSB of addre
 2784 1281 69                      LD       L,C         ; Next string area+1 to
 2785 1282 60                      LD       H,B
 2786 1283 2B                      DEC      HL          ; Next string area addr
 2787 1284 C3D711                  JP       GARBLP      ; Look for more strings
 2788                   ;
 2789 1287 C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2790 1288 E5                      PUSH     HL          ;
 2791 1289 2A2981                  LD       HL,(FPREG)  ; Get first string
 2792 128C E3                      EX       (SP),HL     ; Save first string
 2793 128D CD410D                  CALL     OPRND       ; Get second string
 2794 1290 E3                      EX       (SP),HL     ; Restore first string
 2795 1291 CDBC0C                  CALL     TSTSTR      ; Make sure it's a stri
 2796 1294 7E                      LD       A,(HL)      ; Get length of second 
 2797 1295 E5                      PUSH     HL          ; Save first string
 2798 1296 2A2981                  LD       HL,(FPREG)  ; Get second string
 2799 1299 E5                      PUSH     HL          ; Save second string
 2800 129A 86                      ADD      A,(HL)      ; Add length of second 
 2801 129B 1E1C                    LD       E,LS        ; ?LS Error
 2802 129D DA0704                  JP       C,ERROR     ; String too long - Err
 2803 12A0 CD4011                  CALL     MKTMST      ; Make temporary string
 2804 12A3 D1                      POP      DE          ; Get second string to 
 2805 12A4 CDD812                  CALL     GSTRDE      ; Move to string pool i
 2806 12A7 E3                      EX       (SP),HL     ; Get first string
 2807 12A8 CDD712                  CALL     GSTRHL      ; Move to string pool i
 2808 12AB E5                      PUSH     HL          ; Save first string
 2809 12AC 2A0681                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2810 12AF EB                      EX       DE,HL       ; To DE
 2811 12B0 CDBE12                  CALL     SSTSA       ; First string to strin
 2812 12B3 CDBE12                  CALL     SSTSA       ; Second string to stri
 2813 12B6 21D60C                  LD       HL,EVAL2    ; Return to evaluation 
 2814 12B9 E3                      EX       (SP),HL     ; Save return,get code 
 2815 12BA E5                      PUSH     HL          ; Save code string addr
 2816 12BB C37111                  JP       TSTOPL      ; To temporary string t
 2817                   ;
 2818 12BE E1           SSTSA:     POP      HL          ; Return address
 2819 12BF E3                      EX       (SP),HL     ; Get string block,save
 2820 12C0 7E                      LD       A,(HL)      ; Get length of string
 2821 12C1 23                      INC      HL
 2822 12C2 23                      INC      HL
 2823 12C3 4E                      LD       C,(HL)      ; Get LSB of string add
 2824 12C4 23                      INC      HL
 2825 12C5 46                      LD       B,(HL)      ; Get MSB of string add
 2826 12C6 6F                      LD       L,A         ; Length to L
 2827 12C7 2C           TOSTRA:    INC      L           ; INC - DECed after
 2828 12C8 2D           TSALP:     DEC      L           ; Count bytes moved
 2829 12C9 C8                      RET      Z           ; End of string - Retur
 2830 12CA 0A                      LD       A,(BC)      ; Get source
 2831 12CB 12                      LD       (DE),A      ; Save destination
 2832 12CC 03                      INC      BC          ; Next source
 2833 12CD 13                      INC      DE          ; Next destination
 2834 12CE C3C812                  JP       TSALP       ; Loop until string mov
 2835                   ;
 2836 12D1 CDBC0C       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2837 12D4 2A2981       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2838 12D7 EB           GSTRHL:    EX       DE,HL       ; Save DE
 2839 12D8 CDF212       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2840 12DB EB                      EX       DE,HL       ; Restore DE
 2841 12DC C0                      RET      NZ          ; No - Return
 2842 12DD D5                      PUSH     DE          ; Save string
 2843 12DE 50                      LD       D,B         ; String block address 
 2844 12DF 59                      LD       E,C
 2845 12E0 1B                      DEC      DE          ; Point to length
 2846 12E1 4E                      LD       C,(HL)      ; Get string length
 2847 12E2 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2848 12E5 CDBB06                  CALL     CPDEHL      ; Last one in string ar
 2849 12E8 C2F012                  JP       NZ,POPHL    ; No - Return
 2850 12EB 47                      LD       B,A         ; Clear B (A=0)
 2851 12EC 09                      ADD      HL,BC       ; Remove string from st
 2852 12ED 220881                  LD       (STRBOT),HL ; Save new bottom of st
 2853 12F0 E1           POPHL:     POP      HL          ; Restore string
 2854 12F1 C9                      RET
 2855                   ;
 2856 12F2 2AF680       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2857 12F5 2B                      DEC      HL          ; Back
 2858 12F6 46                      LD       B,(HL)      ; Get MSB of address
 2859 12F7 2B                      DEC      HL          ; Back
 2860 12F8 4E                      LD       C,(HL)      ; Get LSB of address
 2861 12F9 2B                      DEC      HL          ; Back
 2862 12FA 2B                      DEC      HL          ; Back
 2863 12FB CDBB06                  CALL     CPDEHL      ; String last in string
 2864 12FE C0                      RET      NZ          ; Yes - Leave it
 2865 12FF 22F680                  LD       (TMSTPT),HL ; Save new string pool 
 2866 1302 C9                      RET
 2867                   ;
 2868 1303 018210       LEN:       LD       BC,PASSA    ; To return integer A
 2869 1306 C5                      PUSH     BC          ; Save address
 2870 1307 CDD112       GETLEN:    CALL     GETSTR      ; Get string and its le
 2871 130A AF                      XOR      A
 2872 130B 57                      LD       D,A         ; Clear D
 2873 130C 32F280                  LD       (TYPE),A    ; Set type to numeric
 2874 130F 7E                      LD       A,(HL)      ; Get length of string
 2875 1310 B7                      OR       A           ; Set status flags
 2876 1311 C9                      RET
 2877                   ;
 2878 1312 018210       ASC:       LD       BC,PASSA    ; To return integer A
 2879 1315 C5                      PUSH     BC          ; Save address
 2880 1316 CD0713       GTFLNM:    CALL     GETLEN      ; Get length of string
 2881 1319 CA1209                  JP       Z,FCERR     ; Null string - Error
 2882 131C 23                      INC      HL
 2883 131D 23                      INC      HL
 2884 131E 5E                      LD       E,(HL)      ; Get LSB of address
 2885 131F 23                      INC      HL
 2886 1320 56                      LD       D,(HL)      ; Get MSB of address
 2887 1321 1A                      LD       A,(DE)      ; Get first byte of str
 2888 1322 C9                      RET
 2889                   ;
 2890 1323 3E01         CHR:       LD       A,1         ; One character string
 2891 1325 CD4011                  CALL     MKTMST      ; Make a temporary stri
 2892 1328 CD1C14                  CALL     MAKINT      ; Make it integer A
 2893 132B 2A0681                  LD       HL,(TMPSTR+2) ; Get address of stri
 2894 132E 73                      LD       (HL),E      ; Save character
 2895 132F C1           TOPOOL:    POP      BC          ; Clean up stack
 2896 1330 C37111                  JP       TSTOPL      ; Temporary string to p
 2897                   ;
 2898 1333 CDCC13       LEFT:      CALL     LFRGNM      ; Get number and ending
 2899 1336 AF                      XOR      A           ; Start at first byte i
 2900 1337 E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 2901 1338 4F                      LD       C,A         ; Starting position in 
 2902 1339 E5           MID1:      PUSH     HL          ; Save string block add
 2903 133A 7E                      LD       A,(HL)      ; Get length of string
 2904 133B B8                      CP       B           ; Compare with number g
 2905 133C DA4113                  JP       C,ALLFOL    ; All following bytes r
 2906 133F 78                      LD       A,B         ; Get new length
 2907 1340 11                      DB       11H         ; Skip "LD C,0"
 2908 1341 0E00         ALLFOL:    LD       C,0         ; First byte of string
 2909 1343 C5                      PUSH     BC          ; Save position in stri
 2910 1344 CDAA11                  CALL     TESTR       ; See if enough string 
 2911 1347 C1                      POP      BC          ; Get position in strin
 2912 1348 E1                      POP      HL          ; Restore string block 
 2913 1349 E5                      PUSH     HL          ; And re-save it
 2914 134A 23                      INC      HL
 2915 134B 23                      INC      HL
 2916 134C 46                      LD       B,(HL)      ; Get LSB of address
 2917 134D 23                      INC      HL
 2918 134E 66                      LD       H,(HL)      ; Get MSB of address
 2919 134F 68                      LD       L,B         ; HL = address of strin
 2920 1350 0600                    LD       B,0         ; BC = starting address
 2921 1352 09                      ADD      HL,BC       ; Point to that byte
 2922 1353 44                      LD       B,H         ; BC = source string
 2923 1354 4D                      LD       C,L
 2924 1355 CD4311                  CALL     CRTMST      ; Create a string entry
 2925 1358 6F                      LD       L,A         ; Length of new string
 2926 1359 CDC712                  CALL     TOSTRA      ; Move string to string
 2927 135C D1                      POP      DE          ; Clear stack
 2928 135D CDD812                  CALL     GSTRDE      ; Move to string pool i
 2929 1360 C37111                  JP       TSTOPL      ; Temporary string to p
 2930                   ;
 2931 1363 CDCC13       RIGHT:     CALL     LFRGNM      ; Get number and ending
 2932 1366 D1                      POP      DE          ; Get string length
 2933 1367 D5                      PUSH     DE          ; And re-save
 2934 1368 1A                      LD       A,(DE)      ; Get length
 2935 1369 90                      SUB      B           ; Move back N bytes
 2936 136A C33713                  JP       RIGHT1      ; Go and get sub-string
 2937                   ;
 2938 136D EB           MID:       EX       DE,HL       ; Get code string addre
 2939 136E 7E                      LD       A,(HL)      ; Get next byte ',' or 
 2940 136F CDD113                  CALL     MIDNUM      ; Get number supplied
 2941 1372 04                      INC      B           ; Is it character zero?
 2942 1373 05                      DEC      B
 2943 1374 CA1209                  JP       Z,FCERR     ; Yes - Error
 2944 1377 C5                      PUSH     BC          ; Save starting positio
 2945 1378 1EFF                    LD       E,255       ; All of string
 2946 137A FE29                    CP       ')'         ; Any length given?
 2947 137C CA8613                  JP       Z,RSTSTR    ; No - Rest of string
 2948 137F CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 2949 1382 2C                      DB       ','
 2950 1383 CD1914                  CALL     GETINT      ; Get integer 0-255
 2951 1386 CDC106       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 2952 1389 29                      DB       ")"
 2953 138A F1                      POP      AF          ; Restore starting posi
 2954 138B E3                      EX       (SP),HL     ; Get string,8ave code 
 2955 138C 013913                  LD       BC,MID1     ; Continuation of MID$ 
 2956 138F C5                      PUSH     BC          ; Save for return
 2957 1390 3D                      DEC      A           ; Starting position-1
 2958 1391 BE                      CP       (HL)        ; Compare with length
 2959 1392 0600                    LD       B,0         ; Zero bytes length
 2960 1394 D0                      RET      NC          ; Null string if start 
 2961 1395 4F                      LD       C,A         ; Save starting positio
 2962 1396 7E                      LD       A,(HL)      ; Get length of string
 2963 1397 91                      SUB      C           ; Subtract start
 2964 1398 BB                      CP       E           ; Enough string for it?
 2965 1399 47                      LD       B,A         ; Save maximum length a
 2966 139A D8                      RET      C           ; Truncate string if ne
 2967 139B 43                      LD       B,E         ; Set specified length
 2968 139C C9                      RET                  ; Go and create string
 2969                   ;
 2970 139D CD0713       VAL:       CALL     GETLEN      ; Get length of string
 2971 13A0 CABA14                  JP       Z,RESZER    ; Result zero
 2972 13A3 5F                      LD       E,A         ; Save length
 2973 13A4 23                      INC      HL
 2974 13A5 23                      INC      HL
 2975 13A6 7E                      LD       A,(HL)      ; Get LSB of address
 2976 13A7 23                      INC      HL
 2977 13A8 66                      LD       H,(HL)      ; Get MSB of address
 2978 13A9 6F                      LD       L,A         ; HL = String address
 2979 13AA E5                      PUSH     HL          ; Save string address
 2980 13AB 19                      ADD      HL,DE
 2981 13AC 46                      LD       B,(HL)      ; Get end of string+1 b
 2982 13AD 72                      LD       (HL),D      ; Zero it to terminate
 2983 13AE E3                      EX       (SP),HL     ; Save string end,get s
 2984 13AF C5                      PUSH     BC          ; Save end+1 byte
 2985 13B0 7E                      LD       A,(HL)      ; Get starting byte
 2986 13B1 FE24                    CP       '$'         ; Hex number indicated?
 2987 13B3 C2BB13                  JP       NZ,VAL1
 2988 13B6 CDE51B                  CALL     HEXTFP      ; Convert Hex to FPREG
 2989 13B9 180D                    JR       VAL3
 2990 13BB FE25         VAL1:      CP       '%'         ; Binary number indicat
 2991 13BD C2C513                  JP       NZ,VAL2
 2992 13C0 CD551C                  CALL     BINTFP      ; Convert Bin to FPREG
 2993 13C3 1803                    JR       VAL3
 2994 13C5 CDA117       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 2995 13C8 C1           VAL3:      POP      BC          ; Restore end+1 byte
 2996 13C9 E1                      POP      HL          ; Restore end+1 address
 2997 13CA 70                      LD       (HL),B      ; Put back original byt
 2998 13CB C9                      RET
 2999                   ;
 3000 13CC EB           LFRGNM:    EX       DE,HL       ; Code string address t
 3001 13CD CDC106                  CALL     CHKSYN      ; Make sure ")" follows
 3002 13D0 29                      DB       ")"
 3003 13D1 C1           MIDNUM:    POP      BC          ; Get return address
 3004 13D2 D1                      POP      DE          ; Get number supplied
 3005 13D3 C5                      PUSH     BC          ; Re-save return addres
 3006 13D4 43                      LD       B,E         ; Number to B
 3007 13D5 C9                      RET
 3008                   ;
 3009 13D6 CD1C14       INP:       CALL     MAKINT      ; Make it integer A
 3010 13D9 328480                  LD       (INPORT),A  ; Set input port
 3011 13DC CD8380                  CALL     INPSUB      ; Get input from port
 3012 13DF C38210                  JP       PASSA       ; Return integer A
 3013                   ;
 3014 13E2 CD0614       POUT:      CALL     SETIO       ; Set up port number
 3015 13E5 C34B80                  JP       OUTSUB      ; Output data and retur
 3016                   ;
 3017 13E8 CD0614       WAIT:      CALL     SETIO       ; Set up port number
 3018 13EB F5                      PUSH     AF          ; Save AND mask
 3019 13EC 1E00                    LD       E,0         ; Assume zero if none g
 3020 13EE 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3021 13EF CD4B08                  CALL     GETCHR      ; Get next character
 3022 13F2 CAFC13                  JP       Z,NOXOR     ; No XOR byte given
 3023 13F5 CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 3024 13F8 2C                      DB       ','
 3025 13F9 CD1914                  CALL     GETINT      ; Get integer 0-255 to 
 3026 13FC C1           NOXOR:     POP      BC          ; Restore AND mask
 3027 13FD CD8380       WAITLP:    CALL     INPSUB      ; Get input
 3028 1400 AB                      XOR      E           ; Flip selected bits
 3029 1401 A0                      AND      B           ; Result non-zero?
 3030 1402 CAFD13                  JP       Z,WAITLP    ; No = keep waiting
 3031 1405 C9                      RET
 3032                   ;
 3033 1406 CD1914       SETIO:     CALL     GETINT      ; Get integer 0-255
 3034 1409 328480                  LD       (INPORT),A  ; Set input port
 3035 140C 324C80                  LD       (OTPORT),A  ; Set output port
 3036 140F CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 3037 1412 2C                      DB       ','
 3038 1413 C31914                  JP       GETINT      ; Get integer 0-255 and
 3039                   ;
 3040 1416 CD4B08       FNDNUM:    CALL     GETCHR      ; Get next character
 3041 1419 CDB80C       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3042 141C CDF708       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3043 141F 7A                      LD       A,D         ; Get MSB of number
 3044 1420 B7                      OR       A           ; Zero?
 3045 1421 C21209                  JP       NZ,FCERR    ; No - Error
 3046 1424 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3047 1425 CD4B08                  CALL     GETCHR      ; Get next character
 3048 1428 7B                      LD       A,E         ; Get number to A
 3049 1429 C9                      RET
 3050                   ;
 3051 142A CDFD08       PEEK:      CALL     DEINT       ; Get memory address
 3052 142D 1A                      LD       A,(DE)      ; Get byte in memory
 3053 142E C38210                  JP       PASSA       ; Return integer A
 3054                   ;
 3055 1431 CDB80C       POKE:      CALL     GETNUM      ; Get memory address
 3056 1434 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 3057 1437 D5                      PUSH     DE          ; Save memory address
 3058 1438 CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 3059 143B 2C                      DB       ','
 3060 143C CD1914                  CALL     GETINT      ; Get integer 0-255
 3061 143F D1                      POP      DE          ; Restore memory addres
 3062 1440 12                      LD       (DE),A      ; Load it into memory
 3063 1441 C9                      RET
 3064                   ;
 3065 1442 211819       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3066 1445 CDE916       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3067 1448 C35414                  JP       FPADD       ; Add BCDE to FPREG
 3068                   ;
 3069 144B CDE916       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3070 144E 21                      DB       21H         ; Skip "POP BC" and "PO
 3071 144F C1           PSUB:      POP      BC          ; Get FP number from st
 3072 1450 D1                      POP      DE
 3073 1451 CDC316       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3074 1454 78           FPADD:     LD       A,B         ; Get FP exponent
 3075 1455 B7                      OR       A           ; Is number zero?
 3076 1456 C8                      RET      Z           ; Yes - Nothing to add
 3077 1457 3A2C81                  LD       A,(FPEXP)   ; Get FPREG exponent
 3078 145A B7                      OR       A           ; Is this number zero?
 3079 145B CADB16                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3080 145E 90                      SUB      B           ; BCDE number larger?
 3081 145F D26E14                  JP       NC,NOSWAP   ; No - Don't swap them
 3082 1462 2F                      CPL                  ; Two's complement
 3083 1463 3C                      INC      A           ;       FP exponent
 3084 1464 EB                      EX       DE,HL
 3085 1465 CDCB16                  CALL     STAKFP      ; Put FPREG on stack
 3086 1468 EB                      EX       DE,HL
 3087 1469 CDDB16                  CALL     FPBCDE      ; Move BCDE to FPREG
 3088 146C C1                      POP      BC          ; Restore number from s
 3089 146D D1                      POP      DE
 3090 146E FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3091 1470 D0                      RET      NC          ; Yes - First number is
 3092 1471 F5                      PUSH     AF          ; Save number of bits t
 3093 1472 CD0017                  CALL     SIGNS       ; Set MSBs & sign of re
 3094 1475 67                      LD       H,A         ; Save sign of result
 3095 1476 F1                      POP      AF          ; Restore scaling facto
 3096 1477 CD1915                  CALL     SCALE       ; Scale BCDE to same ex
 3097 147A B4                      OR       H           ; Result to be positive
 3098 147B 212981                  LD       HL,FPREG    ; Point to FPREG
 3099 147E F29414                  JP       P,MINCDE    ; No - Subtract FPREG f
 3100 1481 CDF914                  CALL     PLUCDE      ; Add FPREG to CDE
 3101 1484 D2DA14                  JP       NC,RONDUP   ; No overflow - Round i
 3102 1487 23                      INC      HL          ; Point to exponent
 3103 1488 34                      INC      (HL)        ; Increment it
 3104 1489 CA0204                  JP       Z,OVERR     ; Number overflowed - E
 3105 148C 2E01                    LD       L,1         ; 1 bit to shift right
 3106 148E CD2F15                  CALL     SHRT1       ; Shift result right
 3107 1491 C3DA14                  JP       RONDUP      ; Round it up
 3108                   ;
 3109 1494 AF           MINCDE:    XOR      A           ; Clear A and carry
 3110 1495 90                      SUB      B           ; Negate exponent
 3111 1496 47                      LD       B,A         ; Re-save exponent
 3112 1497 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3113 1498 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3114 1499 5F                      LD       E,A         ; Save LSB of BCDE
 3115 149A 23                      INC      HL
 3116 149B 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3117 149C 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3118 149D 57                      LD       D,A         ; Save NMSB of BCDE
 3119 149E 23                      INC      HL
 3120 149F 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3121 14A0 99                      SBC      A,C         ; Subtract MSB of BCDE
 3122 14A1 4F                      LD       C,A         ; Save MSB of BCDE
 3123 14A2 DC0515       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3124                   ;
 3125 14A5 68           BNORM:     LD       L,B         ; L = Exponent
 3126 14A6 63                      LD       H,E         ; H = LSB
 3127 14A7 AF                      XOR      A
 3128 14A8 47           BNRMLP:    LD       B,A         ; Save bit count
 3129 14A9 79                      LD       A,C         ; Get MSB
 3130 14AA B7                      OR       A           ; Is it zero?
 3131 14AB C2C714                  JP       NZ,PNORM    ; No - Do it bit at a t
 3132 14AE 4A                      LD       C,D         ; MSB = NMSB
 3133 14AF 54                      LD       D,H         ; NMSB= LSB
 3134 14B0 65                      LD       H,L         ; LSB = VLSB
 3135 14B1 6F                      LD       L,A         ; VLSB= 0
 3136 14B2 78                      LD       A,B         ; Get exponent
 3137 14B3 D608                    SUB      8           ; Count 8 bits
 3138 14B5 FEE0                    CP       0E0H        ; -24-8 Was number zero
 3139 14B7 C2A814                  JP       NZ,BNRMLP   ; No - Keep normalising
 3140 14BA AF           RESZER:    XOR      A           ; Result is zero
 3141 14BB 322C81       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3142 14BE C9                      RET
 3143                   ;
 3144 14BF 05           NORMAL:    DEC      B           ; Count bits
 3145 14C0 29                      ADD      HL,HL       ; Shift HL left
 3146 14C1 7A                      LD       A,D         ; Get NMSB
 3147 14C2 17                      RLA                  ; Shift left with last 
 3148 14C3 57                      LD       D,A         ; Save NMSB
 3149 14C4 79                      LD       A,C         ; Get MSB
 3150 14C5 8F                      ADC      A,A         ; Shift left with last 
 3151 14C6 4F                      LD       C,A         ; Save MSB
 3152 14C7 F2BF14       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3153 14CA 78                      LD       A,B         ; Number of bits shifte
 3154 14CB 5C                      LD       E,H         ; Save HL in EB
 3155 14CC 45                      LD       B,L
 3156 14CD B7                      OR       A           ; Any shifting done?
 3157 14CE CADA14                  JP       Z,RONDUP    ; No - Round it up
 3158 14D1 212C81                  LD       HL,FPEXP    ; Point to exponent
 3159 14D4 86                      ADD      A,(HL)      ; Add shifted bits
 3160 14D5 77                      LD       (HL),A      ; Re-save exponent
 3161 14D6 D2BA14                  JP       NC,RESZER   ; Underflow - Result is
 3162 14D9 C8                      RET      Z           ; Result is zero
 3163 14DA 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3164 14DB 212C81       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3165 14DE B7                      OR       A           ; Any rounding?
 3166 14DF FCEC14                  CALL     M,FPROND    ; Yes - Round number up
 3167 14E2 46                      LD       B,(HL)      ; B = Exponent
 3168 14E3 23                      INC      HL
 3169 14E4 7E                      LD       A,(HL)      ; Get sign of result
 3170 14E5 E680                    AND      10000000B   ; Only bit 7 needed
 3171 14E7 A9                      XOR      C           ; Set correct sign
 3172 14E8 4F                      LD       C,A         ; Save correct sign in 
 3173 14E9 C3DB16                  JP       FPBCDE      ; Move BCDE to FPREG
 3174                   ;
 3175 14EC 1C           FPROND:    INC      E           ; Round LSB
 3176 14ED C0                      RET      NZ          ; Return if ok
 3177 14EE 14                      INC      D           ; Round NMSB
 3178 14EF C0                      RET      NZ          ; Return if ok
 3179 14F0 0C                      INC      C           ; Round MSB
 3180 14F1 C0                      RET      NZ          ; Return if ok
 3181 14F2 0E80                    LD       C,80H       ; Set normal value
 3182 14F4 34                      INC      (HL)        ; Increment exponent
 3183 14F5 C0                      RET      NZ          ; Return if ok
 3184 14F6 C30204                  JP       OVERR       ; Overflow error
 3185                   ;
 3186 14F9 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3187 14FA 83                      ADD      A,E         ; Add LSB of BCDE
 3188 14FB 5F                      LD       E,A         ; Save LSB of BCDE
 3189 14FC 23                      INC      HL
 3190 14FD 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3191 14FE 8A                      ADC      A,D         ; Add NMSB of BCDE
 3192 14FF 57                      LD       D,A         ; Save NMSB of BCDE
 3193 1500 23                      INC      HL
 3194 1501 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3195 1502 89                      ADC      A,C         ; Add MSB of BCDE
 3196 1503 4F                      LD       C,A         ; Save MSB of BCDE
 3197 1504 C9                      RET
 3198                   ;
 3199 1505 212D81       COMPL:     LD       HL,SGNRES   ; Sign of result
 3200 1508 7E                      LD       A,(HL)      ; Get sign of result
 3201 1509 2F                      CPL                  ; Negate it
 3202 150A 77                      LD       (HL),A      ; Put it back
 3203 150B AF                      XOR      A
 3204 150C 6F                      LD       L,A         ; Set L to zero
 3205 150D 90                      SUB      B           ; Negate exponent,set c
 3206 150E 47                      LD       B,A         ; Re-save exponent
 3207 150F 7D                      LD       A,L         ; Load zero
 3208 1510 9B                      SBC      A,E         ; Negate LSB
 3209 1511 5F                      LD       E,A         ; Re-save LSB
 3210 1512 7D                      LD       A,L         ; Load zero
 3211 1513 9A                      SBC      A,D         ; Negate NMSB
 3212 1514 57                      LD       D,A         ; Re-save NMSB
 3213 1515 7D                      LD       A,L         ; Load zero
 3214 1516 99                      SBC      A,C         ; Negate MSB
 3215 1517 4F                      LD       C,A         ; Re-save MSB
 3216 1518 C9                      RET
 3217                   ;
 3218 1519 0600         SCALE:     LD       B,0         ; Clear underflow
 3219 151B D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3220 151D DA2815                  JP       C,SHRITE    ; No - Shift right A bi
 3221 1520 43                      LD       B,E         ; <- Shift
 3222 1521 5A                      LD       E,D         ; <- right
 3223 1522 51                      LD       D,C         ; <- eight
 3224 1523 0E00                    LD       C,0         ; <- bits
 3225 1525 C31B15                  JP       SCALLP      ; More bits to shift
 3226                   ;
 3227 1528 C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3228 152A 6F                      LD       L,A         ; Save bits to shift
 3229 152B AF           SHRLP:     XOR      A           ; Flag for all done
 3230 152C 2D                      DEC      L           ; All shifting done?
 3231 152D C8                      RET      Z           ; Yes - Return
 3232 152E 79                      LD       A,C         ; Get MSB
 3233 152F 1F           SHRT1:     RRA                  ; Shift it right
 3234 1530 4F                      LD       C,A         ; Re-save
 3235 1531 7A                      LD       A,D         ; Get NMSB
 3236 1532 1F                      RRA                  ; Shift right with last
 3237 1533 57                      LD       D,A         ; Re-save it
 3238 1534 7B                      LD       A,E         ; Get LSB
 3239 1535 1F                      RRA                  ; Shift right with last
 3240 1536 5F                      LD       E,A         ; Re-save it
 3241 1537 78                      LD       A,B         ; Get underflow
 3242 1538 1F                      RRA                  ; Shift right with last
 3243 1539 47                      LD       B,A         ; Re-save underflow
 3244 153A C32B15                  JP       SHRLP       ; More bits to do
 3245                   ;
 3246 153D 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3247                   ;
 3248 1541 03           LOGTAB:    DB       3           ; Table used by LOG
 3249 1542 AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3250 1546 F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3251 154A 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3252                   ;
 3253 154E CD9A16       LOG:       CALL     TSTSGN      ; Test sign of value
 3254 1551 B7                      OR       A
 3255 1552 EA1209                  JP       PE,FCERR    ; ?FC Error if <= zero
 3256 1555 212C81                  LD       HL,FPEXP    ; Point to exponent
 3257 1558 7E                      LD       A,(HL)      ; Get exponent
 3258 1559 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3259 155C 11F304                  LD       DE,04F3H
 3260 155F 90                      SUB      B           ; Scale value to be < 1
 3261 1560 F5                      PUSH     AF          ; Save scale factor
 3262 1561 70                      LD       (HL),B      ; Save new exponent
 3263 1562 D5                      PUSH     DE          ; Save SQR(1/2)
 3264 1563 C5                      PUSH     BC
 3265 1564 CD5414                  CALL     FPADD       ; Add SQR(1/2) to value
 3266 1567 C1                      POP      BC          ; Restore SQR(1/2)
 3267 1568 D1                      POP      DE
 3268 1569 04                      INC      B           ; Make it SQR(2)
 3269 156A CDF015                  CALL     DVBCDE      ; Divide by SQR(2)
 3270 156D 213D15                  LD       HL,UNITY    ; Point to 1.
 3271 1570 CD4B14                  CALL     SUBPHL      ; Subtract FPREG from 1
 3272 1573 214115                  LD       HL,LOGTAB   ; Coefficient table
 3273 1576 CDE219                  CALL     SUMSER      ; Evaluate sum of serie
 3274 1579 018080                  LD       BC,8080H    ; BCDE = -0.5
 3275 157C 110000                  LD       DE,0000H
 3276 157F CD5414                  CALL     FPADD       ; Subtract 0.5 from FPR
 3277 1582 F1                      POP      AF          ; Restore scale factor
 3278 1583 CD1518                  CALL     RSCALE      ; Re-scale number
 3279 1586 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3280 1589 111872                  LD       DE,7218H
 3281 158C 21                      DB       21H         ; Skip "POP BC" and "PO
 3282                   ;
 3283 158D C1           MULT:      POP      BC          ; Get number from stack
 3284 158E D1                      POP      DE
 3285 158F CD9A16       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3286 1592 C8                      RET      Z           ; Return zero if zero
 3287 1593 2E00                    LD       L,0         ; Flag add exponents
 3288 1595 CD5816                  CALL     ADDEXP      ; Add exponents
 3289 1598 79                      LD       A,C         ; Get MSB of multiplier
 3290 1599 323B81                  LD       (MULVAL),A  ; Save MSB of multiplie
 3291 159C EB                      EX       DE,HL
 3292 159D 223C81                  LD       (MULVAL+1),HL ; Save rest of multip
 3293 15A0 010000                  LD       BC,0        ; Partial product (BCDE
 3294 15A3 50                      LD       D,B
 3295 15A4 58                      LD       E,B
 3296 15A5 21A514                  LD       HL,BNORM    ; Address of normalise
 3297 15A8 E5                      PUSH     HL          ; Save for return
 3298 15A9 21B115                  LD       HL,MULT8    ; Address of 8 bit mult
 3299 15AC E5                      PUSH     HL          ; Save for NMSB,MSB
 3300 15AD E5                      PUSH     HL          ;
 3301 15AE 212981                  LD       HL,FPREG    ; Point to number
 3302 15B1 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3303 15B2 23                      INC      HL          ; Point to NMSB
 3304 15B3 B7                      OR       A           ; Test LSB
 3305 15B4 CADD15                  JP       Z,BYTSFT    ; Zero - shift to next 
 3306 15B7 E5                      PUSH     HL          ; Save address of numbe
 3307 15B8 2E08                    LD       L,8         ; 8 bits to multiply by
 3308 15BA 1F           MUL8LP:    RRA                  ; Shift LSB right
 3309 15BB 67                      LD       H,A         ; Save LSB
 3310 15BC 79                      LD       A,C         ; Get MSB
 3311 15BD D2CB15                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3312 15C0 E5                      PUSH     HL          ; Save LSB and count
 3313 15C1 2A3C81                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3314 15C4 19                      ADD      HL,DE       ; Add NMSB and LSB
 3315 15C5 EB                      EX       DE,HL       ; Leave sum in DE
 3316 15C6 E1                      POP      HL          ; Restore MSB and count
 3317 15C7 3A3B81                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3318 15CA 89                      ADC      A,C         ; Add MSB
 3319 15CB 1F           NOMADD:    RRA                  ; Shift MSB right
 3320 15CC 4F                      LD       C,A         ; Re-save MSB
 3321 15CD 7A                      LD       A,D         ; Get NMSB
 3322 15CE 1F                      RRA                  ; Shift NMSB right
 3323 15CF 57                      LD       D,A         ; Re-save NMSB
 3324 15D0 7B                      LD       A,E         ; Get LSB
 3325 15D1 1F                      RRA                  ; Shift LSB right
 3326 15D2 5F                      LD       E,A         ; Re-save LSB
 3327 15D3 78                      LD       A,B         ; Get VLSB
 3328 15D4 1F                      RRA                  ; Shift VLSB right
 3329 15D5 47                      LD       B,A         ; Re-save VLSB
 3330 15D6 2D                      DEC      L           ; Count bits multiplied
 3331 15D7 7C                      LD       A,H         ; Get LSB of multiplier
 3332 15D8 C2BA15                  JP       NZ,MUL8LP   ; More - Do it
 3333 15DB E1           POPHRT:    POP      HL          ; Restore address of nu
 3334 15DC C9                      RET
 3335                   ;
 3336 15DD 43           BYTSFT:    LD       B,E         ; Shift partial product
 3337 15DE 5A                      LD       E,D
 3338 15DF 51                      LD       D,C
 3339 15E0 4F                      LD       C,A
 3340 15E1 C9                      RET
 3341                   ;
 3342 15E2 CDCB16       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3343 15E5 012084                  LD       BC,8420H    ; BCDE = 10.
 3344 15E8 110000                  LD       DE,0000H
 3345 15EB CDDB16                  CALL     FPBCDE      ; Move 10 to FPREG
 3346                   ;
 3347 15EE C1           DIV:       POP      BC          ; Get number from stack
 3348 15EF D1                      POP      DE
 3349 15F0 CD9A16       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3350 15F3 CAF603                  JP       Z,DZERR     ; Error if division by 
 3351 15F6 2EFF                    LD       L,-1        ; Flag subtract exponen
 3352 15F8 CD5816                  CALL     ADDEXP      ; Subtract exponents
 3353 15FB 34                      INC      (HL)        ; Add 2 to exponent to 
 3354 15FC 34                      INC      (HL)
 3355 15FD 2B                      DEC      HL          ; Point to MSB
 3356 15FE 7E                      LD       A,(HL)      ; Get MSB of dividend
 3357 15FF 325780                  LD       (DIV3),A    ; Save for subtraction
 3358 1602 2B                      DEC      HL
 3359 1603 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3360 1604 325380                  LD       (DIV2),A    ; Save for subtraction
 3361 1607 2B                      DEC      HL
 3362 1608 7E                      LD       A,(HL)      ; Get MSB of dividend
 3363 1609 324F80                  LD       (DIV1),A    ; Save for subtraction
 3364 160C 41                      LD       B,C         ; Get MSB
 3365 160D EB                      EX       DE,HL       ; NMSB,LSB to HL
 3366 160E AF                      XOR      A
 3367 160F 4F                      LD       C,A         ; Clear MSB of quotient
 3368 1610 57                      LD       D,A         ; Clear NMSB of quotien
 3369 1611 5F                      LD       E,A         ; Clear LSB of quotient
 3370 1612 325A80                  LD       (DIV4),A    ; Clear overflow count
 3371 1615 E5           DIVLP:     PUSH     HL          ; Save divisor
 3372 1616 C5                      PUSH     BC
 3373 1617 7D                      LD       A,L         ; Get LSB of number
 3374 1618 CD4E80                  CALL     DIVSUP      ; Subt' divisor from di
 3375 161B DE00                    SBC      A,0         ; Count for overflows
 3376 161D 3F                      CCF
 3377 161E D22816                  JP       NC,RESDIV   ; Restore divisor if bo
 3378 1621 325A80                  LD       (DIV4),A    ; Re-save overflow coun
 3379 1624 F1                      POP      AF          ; Scrap divisor
 3380 1625 F1                      POP      AF
 3381 1626 37                      SCF                  ; Set carry to
 3382 1627 D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3383                   ;
 3384 1628 C1           RESDIV:    POP      BC          ; Restore divisor
 3385 1629 E1                      POP      HL
 3386 162A 79                      LD       A,C         ; Get MSB of quotient
 3387 162B 3C                      INC      A
 3388 162C 3D                      DEC      A
 3389 162D 1F                      RRA                  ; Bit 0 to bit 7
 3390 162E FADB14                  JP       M,RONDB     ; Done - Normalise resu
 3391 1631 17                      RLA                  ; Restore carry
 3392 1632 7B                      LD       A,E         ; Get LSB of quotient
 3393 1633 17                      RLA                  ; Double it
 3394 1634 5F                      LD       E,A         ; Put it back
 3395 1635 7A                      LD       A,D         ; Get NMSB of quotient
 3396 1636 17                      RLA                  ; Double it
 3397 1637 57                      LD       D,A         ; Put it back
 3398 1638 79                      LD       A,C         ; Get MSB of quotient
 3399 1639 17                      RLA                  ; Double it
 3400 163A 4F                      LD       C,A         ; Put it back
 3401 163B 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3402 163C 78                      LD       A,B         ; Get MSB of divisor
 3403 163D 17                      RLA                  ; Double it
 3404 163E 47                      LD       B,A         ; Put it back
 3405 163F 3A5A80                  LD       A,(DIV4)    ; Get VLSB of quotient
 3406 1642 17                      RLA                  ; Double it
 3407 1643 325A80                  LD       (DIV4),A    ; Put it back
 3408 1646 79                      LD       A,C         ; Get MSB of quotient
 3409 1647 B2                      OR       D           ; Merge NMSB
 3410 1648 B3                      OR       E           ; Merge LSB
 3411 1649 C21516                  JP       NZ,DIVLP    ; Not done - Keep divid
 3412 164C E5                      PUSH     HL          ; Save divisor
 3413 164D 212C81                  LD       HL,FPEXP    ; Point to exponent
 3414 1650 35                      DEC      (HL)        ; Divide by 2
 3415 1651 E1                      POP      HL          ; Restore divisor
 3416 1652 C21516                  JP       NZ,DIVLP    ; Ok - Keep going
 3417 1655 C30204                  JP       OVERR       ; Overflow error
 3418                   ;
 3419 1658 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3420 1659 B7                      OR       A           ; Test it
 3421 165A CA7C16                  JP       Z,OVTST3    ; Zero - Result zero
 3422 165D 7D                      LD       A,L         ; Get add/subtract flag
 3423 165E 212C81                  LD       HL,FPEXP    ; Point to exponent
 3424 1661 AE                      XOR      (HL)        ; Add or subtract it
 3425 1662 80                      ADD      A,B         ; Add the other exponen
 3426 1663 47                      LD       B,A         ; Save new exponent
 3427 1664 1F                      RRA                  ; Test exponent for ove
 3428 1665 A8                      XOR      B
 3429 1666 78                      LD       A,B         ; Get exponent
 3430 1667 F27B16                  JP       P,OVTST2    ; Positive - Test for o
 3431 166A C680                    ADD      A,80H       ; Add excess 128
 3432 166C 77                      LD       (HL),A      ; Save new exponent
 3433 166D CADB15                  JP       Z,POPHRT    ; Zero - Result zero
 3434 1670 CD0017                  CALL     SIGNS       ; Set MSBs and sign of 
 3435 1673 77                      LD       (HL),A      ; Save new exponent
 3436 1674 2B                      DEC      HL          ; Point to MSB
 3437 1675 C9                      RET
 3438                   ;
 3439 1676 CD9A16       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3440 1679 2F                      CPL                  ; Invert sign
 3441 167A E1                      POP      HL          ; Clean up stack
 3442 167B B7           OVTST2:    OR       A           ; Test if new exponent 
 3443 167C E1           OVTST3:    POP      HL          ; Clear off return addr
 3444 167D F2BA14                  JP       P,RESZER    ; Result zero
 3445 1680 C30204                  JP       OVERR       ; Overflow error
 3446                   ;
 3447 1683 CDE616       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3448 1686 78                      LD       A,B         ; Get exponent
 3449 1687 B7                      OR       A           ; Is it zero?
 3450 1688 C8                      RET      Z           ; Yes - Result is zero
 3451 1689 C602                    ADD      A,2         ; Multiply by 4
 3452 168B DA0204                  JP       C,OVERR     ; Overflow - ?OV Error
 3453 168E 47                      LD       B,A         ; Re-save exponent
 3454 168F CD5414                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3455 1692 212C81                  LD       HL,FPEXP    ; Point to exponent
 3456 1695 34                      INC      (HL)        ; Double number (Times 
 3457 1696 C0                      RET      NZ          ; Ok - Return
 3458 1697 C30204                  JP       OVERR       ; Overflow error
 3459                   ;
 3460 169A 3A2C81       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3461 169D B7                      OR       A
 3462 169E C8                      RET      Z           ; RETurn if number is z
 3463 169F 3A2B81                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3464 16A2 FE                      DB       0FEH        ; Test sign
 3465 16A3 2F           RETREL:    CPL                  ; Invert sign
 3466 16A4 17                      RLA                  ; Sign bit to carry
 3467 16A5 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3468 16A6 C0                      RET      NZ          ; Return -1 if negative
 3469 16A7 3C                      INC      A           ; Bump to +1
 3470 16A8 C9                      RET                  ; Positive - Return +1
 3471                   ;
 3472 16A9 CD9A16       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3473 16AC 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3474 16AE 110000                  LD       DE,0        ; Zero NMSB and LSB
 3475 16B1 212C81       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3476 16B4 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3477 16B5 70                      LD       (HL),B      ; Save exponent
 3478 16B6 0600                    LD       B,0         ; CDE = integer to norm
 3479 16B8 23                      INC      HL          ; Point to sign of resu
 3480 16B9 3680                    LD       (HL),80H    ; Set sign of result
 3481 16BB 17                      RLA                  ; Carry = sign of integ
 3482 16BC C3A214                  JP       CONPOS      ; Set sign of result
 3483                   ;
 3484 16BF CD9A16       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3485 16C2 F0                      RET      P           ; Return if positive
 3486 16C3 212B81       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3487 16C6 7E                      LD       A,(HL)      ; Get sign of mantissa
 3488 16C7 EE80                    XOR      80H         ; Invert sign of mantis
 3489 16C9 77                      LD       (HL),A      ; Re-save sign of manti
 3490 16CA C9                      RET
 3491                   ;
 3492 16CB EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3493 16CC 2A2981                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3494 16CF E3                      EX       (SP),HL     ; Stack them,get return
 3495 16D0 E5                      PUSH     HL          ; Re-save return
 3496 16D1 2A2B81                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3497 16D4 E3                      EX       (SP),HL     ; Stack them,get return
 3498 16D5 E5                      PUSH     HL          ; Re-save return
 3499 16D6 EB                      EX       DE,HL       ; Restore code string a
 3500 16D7 C9                      RET
 3501                   ;
 3502 16D8 CDE916       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3503 16DB EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3504 16DC 222981                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3505 16DF 60                      LD       H,B         ; Exponent of number
 3506 16E0 69                      LD       L,C         ; MSB of number
 3507 16E1 222B81                  LD       (FPREG+2),HL ; Save MSB and exponen
 3508 16E4 EB                      EX       DE,HL       ; Restore code string a
 3509 16E5 C9                      RET
 3510                   ;
 3511 16E6 212981       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3512 16E9 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3513 16EA 23                      INC      HL
 3514 16EB 56                      LD       D,(HL)      ; Get NMSB of number
 3515 16EC 23                      INC      HL
 3516 16ED 4E                      LD       C,(HL)      ; Get MSB of number
 3517 16EE 23                      INC      HL
 3518 16EF 46                      LD       B,(HL)      ; Get exponent of numbe
 3519 16F0 23           INCHL:     INC      HL          ; Used for conditional 
 3520 16F1 C9                      RET
 3521                   ;
 3522 16F2 112981       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3523 16F5 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3524 16F7 1A           DETHLB:    LD       A,(DE)      ; Get source
 3525 16F8 77                      LD       (HL),A      ; Save destination
 3526 16F9 13                      INC      DE          ; Next source
 3527 16FA 23                      INC      HL          ; Next destination
 3528 16FB 05                      DEC      B           ; Count bytes
 3529 16FC C2F716                  JP       NZ,DETHLB   ; Loop if more
 3530 16FF C9                      RET
 3531                   ;
 3532 1700 212B81       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3533 1703 7E                      LD       A,(HL)      ; Get MSB
 3534 1704 07                      RLCA                 ; Old sign to carry
 3535 1705 37                      SCF                  ; Set MSBit
 3536 1706 1F                      RRA                  ; Set MSBit of MSB
 3537 1707 77                      LD       (HL),A      ; Save new MSB
 3538 1708 3F                      CCF                  ; Complement sign
 3539 1709 1F                      RRA                  ; Old sign to carry
 3540 170A 23                      INC      HL
 3541 170B 23                      INC      HL
 3542 170C 77                      LD       (HL),A      ; Set sign of result
 3543 170D 79                      LD       A,C         ; Get MSB
 3544 170E 07                      RLCA                 ; Old sign to carry
 3545 170F 37                      SCF                  ; Set MSBit
 3546 1710 1F                      RRA                  ; Set MSBit of MSB
 3547 1711 4F                      LD       C,A         ; Save MSB
 3548 1712 1F                      RRA
 3549 1713 AE                      XOR      (HL)        ; New sign of result
 3550 1714 C9                      RET
 3551                   ;
 3552 1715 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3553 1716 B7                      OR       A
 3554 1717 CA9A16                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3555 171A 21A316                  LD       HL,RETREL   ; Return relation routi
 3556 171D E5                      PUSH     HL          ; Save for return
 3557 171E CD9A16                  CALL     TSTSGN      ; Test sign of FPREG
 3558 1721 79                      LD       A,C         ; Get MSB of number
 3559 1722 C8                      RET      Z           ; FPREG zero - Number's
 3560 1723 212B81                  LD       HL,FPREG+2  ; MSB of FPREG
 3561 1726 AE                      XOR      (HL)        ; Combine signs
 3562 1727 79                      LD       A,C         ; Get MSB of number
 3563 1728 F8                      RET      M           ; Exit if signs differe
 3564 1729 CD2F17                  CALL     CMPFP       ; Compare FP numbers
 3565 172C 1F                      RRA                  ; Get carry to sign
 3566 172D A9                      XOR      C           ; Combine with MSB of n
 3567 172E C9                      RET
 3568                   ;
 3569 172F 23           CMPFP:     INC      HL          ; Point to exponent
 3570 1730 78                      LD       A,B         ; Get exponent
 3571 1731 BE                      CP       (HL)        ; Compare exponents
 3572 1732 C0                      RET      NZ          ; Different
 3573 1733 2B                      DEC      HL          ; Point to MBS
 3574 1734 79                      LD       A,C         ; Get MSB
 3575 1735 BE                      CP       (HL)        ; Compare MSBs
 3576 1736 C0                      RET      NZ          ; Different
 3577 1737 2B                      DEC      HL          ; Point to NMSB
 3578 1738 7A                      LD       A,D         ; Get NMSB
 3579 1739 BE                      CP       (HL)        ; Compare NMSBs
 3580 173A C0                      RET      NZ          ; Different
 3581 173B 2B                      DEC      HL          ; Point to LSB
 3582 173C 7B                      LD       A,E         ; Get LSB
 3583 173D 96                      SUB      (HL)        ; Compare LSBs
 3584 173E C0                      RET      NZ          ; Different
 3585 173F E1                      POP      HL          ; Drop RETurn
 3586 1740 E1                      POP      HL          ; Drop another RETurn
 3587 1741 C9                      RET
 3588                   ;
 3589 1742 47           FPINT:     LD       B,A         ; <- Move
 3590 1743 4F                      LD       C,A         ; <- exponent
 3591 1744 57                      LD       D,A         ; <- to all
 3592 1745 5F                      LD       E,A         ; <- bits
 3593 1746 B7                      OR       A           ; Test exponent
 3594 1747 C8                      RET      Z           ; Zero - Return zero
 3595 1748 E5                      PUSH     HL          ; Save pointer to numbe
 3596 1749 CDE616                  CALL     BCDEFP      ; Move FPREG to BCDE
 3597 174C CD0017                  CALL     SIGNS       ; Set MSBs & sign of re
 3598 174F AE                      XOR      (HL)        ; Combine with sign of 
 3599 1750 67                      LD       H,A         ; Save combined signs
 3600 1751 FC6617                  CALL     M,DCBCDE    ; Negative - Decrement 
 3601 1754 3E98                    LD       A,80H+24    ; 24 bits
 3602 1756 90                      SUB      B           ; Bits to shift
 3603 1757 CD1915                  CALL     SCALE       ; Shift BCDE
 3604 175A 7C                      LD       A,H         ; Get combined sign
 3605 175B 17                      RLA                  ; Sign to carry
 3606 175C DCEC14                  CALL     C,FPROND    ; Negative - Round numb
 3607 175F 0600                    LD       B,0         ; Zero exponent
 3608 1761 DC0515                  CALL     C,COMPL     ; If negative make posi
 3609 1764 E1                      POP      HL          ; Restore pointer to nu
 3610 1765 C9                      RET
 3611                   ;
 3612 1766 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3613 1767 7A                      LD       A,D         ; Test LSBs
 3614 1768 A3                      AND      E
 3615 1769 3C                      INC      A
 3616 176A C0                      RET      NZ          ; Exit if LSBs not FFFF
 3617 176B 0B                      DEC      BC          ; Decrement MSBs
 3618 176C C9                      RET
 3619                   ;
 3620 176D 212C81       INT:       LD       HL,FPEXP    ; Point to exponent
 3621 1770 7E                      LD       A,(HL)      ; Get exponent
 3622 1771 FE98                    CP       80H+24      ; Integer accuracy only
 3623 1773 3A2981                  LD       A,(FPREG)   ; Get LSB
 3624 1776 D0                      RET      NC          ; Yes - Already integer
 3625 1777 7E                      LD       A,(HL)      ; Get exponent
 3626 1778 CD4217                  CALL     FPINT       ; F.P to integer
 3627 177B 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3628 177D 7B                      LD       A,E         ; Get LSB of number
 3629 177E F5                      PUSH     AF          ; Save LSB
 3630 177F 79                      LD       A,C         ; Get MSB of number
 3631 1780 17                      RLA                  ; Sign to carry
 3632 1781 CDA214                  CALL     CONPOS      ; Set sign of result
 3633 1784 F1                      POP      AF          ; Restore LSB of number
 3634 1785 C9                      RET
 3635                   ;
 3636 1786 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3637 1789 78                      LD       A,B         ; Test multiplier
 3638 178A B1                      OR       C
 3639 178B C8                      RET      Z           ; Return zero if zero
 3640 178C 3E10                    LD       A,16        ; 16 bits
 3641 178E 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3642 178F DAC60F                  JP       C,BSERR     ; ?BS Error if overflow
 3643 1792 EB                      EX       DE,HL
 3644 1793 29                      ADD      HL,HL       ; Shift multiplier left
 3645 1794 EB                      EX       DE,HL
 3646 1795 D29C17                  JP       NC,NOMLAD   ; Bit was zero - No add
 3647 1798 09                      ADD      HL,BC       ; Add multiplicand
 3648 1799 DAC60F                  JP       C,BSERR     ; ?BS Error if overflow
 3649 179C 3D           NOMLAD:    DEC      A           ; Count bits
 3650 179D C28E17                  JP       NZ,MLDBLP   ; More
 3651 17A0 C9                      RET
 3652                   ;
 3653 17A1 FE2D         ASCTFP:    CP       '-'         ; Negative?
 3654 17A3 F5                      PUSH     AF          ; Save it and flags
 3655 17A4 CAAD17                  JP       Z,CNVNUM    ; Yes - Convert number
 3656 17A7 FE2B                    CP       '+'         ; Positive?
 3657 17A9 CAAD17                  JP       Z,CNVNUM    ; Yes - Convert number
 3658 17AC 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3659 17AD CDBA14       CNVNUM:    CALL     RESZER      ; Set result to zero
 3660 17B0 47                      LD       B,A         ; Digits after point co
 3661 17B1 57                      LD       D,A         ; Sign of exponent
 3662 17B2 5F                      LD       E,A         ; Exponent of ten
 3663 17B3 2F                      CPL
 3664 17B4 4F                      LD       C,A         ; Before or after point
 3665 17B5 CD4B08       MANLP:     CALL     GETCHR      ; Get next character
 3666 17B8 DAFE17                  JP       C,ADDIG     ; Digit - Add to number
 3667 17BB FE2E                    CP       '.'
 3668 17BD CAD917                  JP       Z,DPOINT    ; '.' - Flag point
 3669 17C0 FE45                    CP       'E'
 3670 17C2 C2DD17                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3671 17C5 CD4B08                  CALL     GETCHR      ; Get next character
 3672 17C8 CDF10D                  CALL     SGNEXP      ; Get sign of exponent
 3673 17CB CD4B08       EXPLP:     CALL     GETCHR      ; Get next character
 3674 17CE DA2018                  JP       C,EDIGIT    ; Digit - Add to expone
 3675 17D1 14                      INC      D           ; Is sign negative?
 3676 17D2 C2DD17                  JP       NZ,CONEXP   ; No - Scale number
 3677 17D5 AF                      XOR      A
 3678 17D6 93                      SUB      E           ; Negate exponent
 3679 17D7 5F                      LD       E,A         ; And re-save it
 3680 17D8 0C                      INC      C           ; Flag end of number
 3681 17D9 0C           DPOINT:    INC      C           ; Flag point passed
 3682 17DA CAB517                  JP       Z,MANLP     ; Zero - Get another di
 3683 17DD E5           CONEXP:    PUSH     HL          ; Save code string addr
 3684 17DE 7B                      LD       A,E         ; Get exponent
 3685 17DF 90                      SUB      B           ; Subtract digits after
 3686 17E0 F4F617       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3687 17E3 F2EC17                  JP       P,ENDCON    ; Positive - All done
 3688 17E6 F5                      PUSH     AF          ; Save number of times 
 3689 17E7 CDE215                  CALL     DIV10       ; Divide by 10
 3690 17EA F1                      POP      AF          ; Restore count
 3691 17EB 3C                      INC      A           ; Count divides
 3692                   ;
 3693 17EC C2E017       ENDCON:    JP       NZ,SCALMI   ; More to do
 3694 17EF D1                      POP      DE          ; Restore code string a
 3695 17F0 F1                      POP      AF          ; Restore sign of numbe
 3696 17F1 CCC316                  CALL     Z,INVSGN    ; Negative - Negate num
 3697 17F4 EB                      EX       DE,HL       ; Code string address t
 3698 17F5 C9                      RET
 3699                   ;
 3700 17F6 C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3701 17F7 F5           MULTEN:    PUSH     AF          ; Save count
 3702 17F8 CD8316                  CALL     MLSP10      ; Multiply number by 10
 3703 17FB F1                      POP      AF          ; Restore count
 3704 17FC 3D                      DEC      A           ; Count multiplies
 3705 17FD C9                      RET
 3706                   ;
 3707 17FE D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3708 17FF 57                      LD       D,A         ; Save digit
 3709 1800 78                      LD       A,B         ; Get digits after poin
 3710 1801 89                      ADC      A,C         ; Add one if after poin
 3711 1802 47                      LD       B,A         ; Re-save counter
 3712 1803 C5                      PUSH     BC          ; Save point flags
 3713 1804 E5                      PUSH     HL          ; Save code string addr
 3714 1805 D5                      PUSH     DE          ; Save digit
 3715 1806 CD8316                  CALL     MLSP10      ; Multiply number by 10
 3716 1809 F1                      POP      AF          ; Restore digit
 3717 180A D630                    SUB      '0'         ; Make it absolute
 3718 180C CD1518                  CALL     RSCALE      ; Re-scale number
 3719 180F E1                      POP      HL          ; Restore code string a
 3720 1810 C1                      POP      BC          ; Restore point flags
 3721 1811 D1                      POP      DE          ; Restore sign of expon
 3722 1812 C3B517                  JP       MANLP       ; Get another digit
 3723                   ;
 3724 1815 CDCB16       RSCALE:    CALL     STAKFP      ; Put number on stack
 3725 1818 CDAC16                  CALL     FLGREL      ; Digit to add to FPREG
 3726 181B C1           PADD:      POP      BC          ; Restore number
 3727 181C D1                      POP      DE
 3728 181D C35414                  JP       FPADD       ; Add BCDE to FPREG and
 3729                   ;
 3730 1820 7B           EDIGIT:    LD       A,E         ; Get digit
 3731 1821 07                      RLCA                 ; Times 2
 3732 1822 07                      RLCA                 ; Times 4
 3733 1823 83                      ADD      A,E         ; Times 5
 3734 1824 07                      RLCA                 ; Times 10
 3735 1825 86                      ADD      A,(HL)      ; Add next digit
 3736 1826 D630                    SUB      '0'         ; Make it absolute
 3737 1828 5F                      LD       E,A         ; Save new digit
 3738 1829 C3CB17                  JP       EXPLP       ; Look for another digi
 3739                   ;
 3740 182C E5           LINEIN:    PUSH     HL          ; Save code string addr
 3741 182D 218B03                  LD       HL,INMSG    ; Output " in "
 3742 1830 CD9111                  CALL     PRS         ; Output string at HL
 3743 1833 E1                      POP      HL          ; Restore code string a
 3744 1834 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3745 1835 AF                      XOR      A
 3746 1836 0698                    LD       B,80H+24    ; 24 bits
 3747 1838 CDB116                  CALL     RETINT      ; Return the integer
 3748 183B 219011                  LD       HL,PRNUMS   ; Print number string
 3749 183E E5                      PUSH     HL          ; Save for return
 3750 183F 212E81       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3751 1842 E5                      PUSH     HL          ; Save for return
 3752 1843 CD9A16                  CALL     TSTSGN      ; Test sign of FPREG
 3753 1846 3620                    LD       (HL),' '    ; Space at start
 3754 1848 F24D18                  JP       P,SPCFST    ; Positive - Space to s
 3755 184B 362D                    LD       (HL),'-'    ; '-' sign at start
 3756 184D 23           SPCFST:    INC      HL          ; First byte of number
 3757 184E 3630                    LD       (HL),'0'    ; '0' if zero
 3758 1850 CA0319                  JP       Z,JSTZER    ; Return '0' if zero
 3759 1853 E5                      PUSH     HL          ; Save buffer address
 3760 1854 FCC316                  CALL     M,INVSGN    ; Negate FPREG if negat
 3761 1857 AF                      XOR      A           ; Zero A
 3762 1858 F5                      PUSH     AF          ; Save it
 3763 1859 CD0919                  CALL     RNGTST      ; Test number is in ran
 3764 185C 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3765 185F 11F84F                  LD       DE,4FF8H
 3766 1862 CD1517                  CALL     CMPNUM      ; Compare numbers
 3767 1865 B7                      OR       A
 3768 1866 E27A18                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3769 1869 F1                      POP      AF          ; Restore count
 3770 186A CDF717                  CALL     MULTEN      ; Multiply by ten
 3771 186D F5                      PUSH     AF          ; Re-save count
 3772 186E C35C18                  JP       SIXDIG      ; Test it again
 3773                   ;
 3774 1871 CDE215       GTSIXD:    CALL     DIV10       ; Divide by 10
 3775 1874 F1                      POP      AF          ; Get count
 3776 1875 3C                      INC      A           ; Count divides
 3777 1876 F5                      PUSH     AF          ; Re-save count
 3778 1877 CD0919                  CALL     RNGTST      ; Test number is in ran
 3779 187A CD4214       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3780 187D 3C                      INC      A
 3781 187E CD4217                  CALL     FPINT       ; F.P to integer
 3782 1881 CDDB16                  CALL     FPBCDE      ; Move BCDE to FPREG
 3783 1884 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3784 1887 F1                      POP      AF          ; Restore count
 3785 1888 81                      ADD      A,C         ; 6 digits before point
 3786 1889 3C                      INC      A           ; Add one
 3787 188A FA9618                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3788 188D FE08                    CP       6+1+1       ; More than 999999 ?
 3789 188F D29618                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3790 1892 3C                      INC      A           ; Adjust for exponent
 3791 1893 47                      LD       B,A         ; Exponent of number
 3792 1894 3E02                    LD       A,2         ; Make it zero after
 3793                   ;
 3794 1896 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3795 1897 3D                      DEC      A
 3796 1898 E1                      POP      HL          ; Restore buffer addres
 3797 1899 F5                      PUSH     AF          ; Save count
 3798 189A 111C19                  LD       DE,POWERS   ; Powers of ten
 3799 189D 05                      DEC      B           ; Count digits before p
 3800 189E C2A718                  JP       NZ,DIGTXT   ; Not zero - Do number
 3801 18A1 362E                    LD       (HL),'.'    ; Save point
 3802 18A3 23                      INC      HL          ; Move on
 3803 18A4 3630                    LD       (HL),'0'    ; Save zero
 3804 18A6 23                      INC      HL          ; Move on
 3805 18A7 05           DIGTXT:    DEC      B           ; Count digits before p
 3806 18A8 362E                    LD       (HL),'.'    ; Save point in case
 3807 18AA CCF016                  CALL     Z,INCHL     ; Last digit - move on
 3808 18AD C5                      PUSH     BC          ; Save digits before po
 3809 18AE E5                      PUSH     HL          ; Save buffer address
 3810 18AF D5                      PUSH     DE          ; Save powers of ten
 3811 18B0 CDE616                  CALL     BCDEFP      ; Move FPREG to BCDE
 3812 18B3 E1                      POP      HL          ; Powers of ten table
 3813 18B4 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3814 18B6 04           TRYAGN:    INC      B           ; Count subtractions
 3815 18B7 7B                      LD       A,E         ; Get LSB
 3816 18B8 96                      SUB      (HL)        ; Subtract LSB
 3817 18B9 5F                      LD       E,A         ; Save LSB
 3818 18BA 23                      INC      HL
 3819 18BB 7A                      LD       A,D         ; Get NMSB
 3820 18BC 9E                      SBC      A,(HL)      ; Subtract NMSB
 3821 18BD 57                      LD       D,A         ; Save NMSB
 3822 18BE 23                      INC      HL
 3823 18BF 79                      LD       A,C         ; Get MSB
 3824 18C0 9E                      SBC      A,(HL)      ; Subtract MSB
 3825 18C1 4F                      LD       C,A         ; Save MSB
 3826 18C2 2B                      DEC      HL          ; Point back to start
 3827 18C3 2B                      DEC      HL
 3828 18C4 D2B618                  JP       NC,TRYAGN   ; No overflow - Try aga
 3829 18C7 CDF914                  CALL     PLUCDE      ; Restore number
 3830 18CA 23                      INC      HL          ; Start of next number
 3831 18CB CDDB16                  CALL     FPBCDE      ; Move BCDE to FPREG
 3832 18CE EB                      EX       DE,HL       ; Save point in table
 3833 18CF E1                      POP      HL          ; Restore buffer addres
 3834 18D0 70                      LD       (HL),B      ; Save digit in buffer
 3835 18D1 23                      INC      HL          ; And move on
 3836 18D2 C1                      POP      BC          ; Restore digit count
 3837 18D3 0D                      DEC      C           ; Count digits
 3838 18D4 C2A718                  JP       NZ,DIGTXT   ; More - Do them
 3839 18D7 05                      DEC      B           ; Any decimal part?
 3840 18D8 CAE718                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3841 18DB 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3842 18DC 7E                      LD       A,(HL)      ; Get character
 3843 18DD FE30                    CP       '0'         ; '0' character?
 3844 18DF CADB18                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3845 18E2 FE2E                    CP       '.'         ; A decimal point?
 3846 18E4 C4F016                  CALL     NZ,INCHL    ; Move back over digit
 3847                   ;
 3848 18E7 F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3849 18E8 CA0619                  JP       Z,NOENED    ; No 'E' needed - End b
 3850 18EB 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3851 18ED 23                      INC      HL          ; And move on
 3852 18EE 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3853 18F0 F2F718                  JP       P,OUTEXP    ; Positive - Output exp
 3854 18F3 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3855 18F5 2F                      CPL                  ; Negate exponent
 3856 18F6 3C                      INC      A
 3857 18F7 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3858 18F9 04           EXPTEN:    INC      B           ; Count subtractions
 3859 18FA D60A                    SUB      10          ; Tens digit
 3860 18FC D2F918                  JP       NC,EXPTEN   ; More to do
 3861 18FF C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3862 1901 23                      INC      HL          ; Move on
 3863 1902 70                      LD       (HL),B      ; Save MSB of exponent
 3864 1903 23           JSTZER:    INC      HL          ;
 3865 1904 77                      LD       (HL),A      ; Save LSB of exponent
 3866 1905 23                      INC      HL
 3867 1906 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3868 1907 E1                      POP      HL          ; Restore code string a
 3869 1908 C9                      RET
 3870                   ;
 3871 1909 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3872 190C 11F723                  LD       DE,23F7H
 3873 190F CD1517                  CALL     CMPNUM      ; Compare numbers
 3874 1912 B7                      OR       A
 3875 1913 E1                      POP      HL          ; Return address to HL
 3876 1914 E27118                  JP       PO,GTSIXD   ; Too big - Divide by t
 3877 1917 E9                      JP       (HL)        ; Otherwise return to c
 3878                   ;
 3879 1918 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3880                   ;
 3881 191C A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3882 191F 102700                  DB       010H,027H,000H ; 10000
 3883 1922 E80300                  DB       0E8H,003H,000H ; 1000
 3884 1925 640000                  DB       064H,000H,000H ; 100
 3885 1928 0A0000                  DB       00AH,000H,000H ; 10
 3886 192B 010000                  DB       001H,000H,000H ; 1
 3887                   ;
 3888 192E 21C316       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3889 1931 E3                      EX       (SP),HL     ; To be done after call
 3890 1932 E9                      JP       (HL)        ; Return to caller
 3891                   ;
 3892 1933 CDCB16       SQR:       CALL     STAKFP      ; Put value on stack
 3893 1936 211819                  LD       HL,HALF     ; Set power to 1/2
 3894 1939 CDD816                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3895                   ;
 3896 193C C1           POWER:     POP      BC          ; Get base
 3897 193D D1                      POP      DE
 3898 193E CD9A16                  CALL     TSTSGN      ; Test sign of power
 3899 1941 78                      LD       A,B         ; Get exponent of base
 3900 1942 CA8119                  JP       Z,EXP       ; Make result 1 if zero
 3901 1945 F24C19                  JP       P,POWER1    ; Positive base - Ok
 3902 1948 B7                      OR       A           ; Zero to negative powe
 3903 1949 CAF603                  JP       Z,DZERR     ; Yes - ?/0 Error
 3904 194C B7           POWER1:    OR       A           ; Base zero?
 3905 194D CABB14                  JP       Z,SAVEXP    ; Yes - Return zero
 3906 1950 D5                      PUSH     DE          ; Save base
 3907 1951 C5                      PUSH     BC
 3908 1952 79                      LD       A,C         ; Get MSB of base
 3909 1953 F67F                    OR       01111111B   ; Get sign status
 3910 1955 CDE616                  CALL     BCDEFP      ; Move power to BCDE
 3911 1958 F26919                  JP       P,POWER2    ; Positive base - Ok
 3912 195B D5                      PUSH     DE          ; Save power
 3913 195C C5                      PUSH     BC
 3914 195D CD6D17                  CALL     INT         ; Get integer of power
 3915 1960 C1                      POP      BC          ; Restore power
 3916 1961 D1                      POP      DE
 3917 1962 F5                      PUSH     AF          ; MSB of base
 3918 1963 CD1517                  CALL     CMPNUM      ; Power an integer?
 3919 1966 E1                      POP      HL          ; Restore MSB of base
 3920 1967 7C                      LD       A,H         ; but don't affect flag
 3921 1968 1F                      RRA                  ; Exponent odd or even?
 3922 1969 E1           POWER2:    POP      HL          ; Restore MSB and expon
 3923 196A 222B81                  LD       (FPREG+2),HL ; Save base in FPREG
 3924 196D E1                      POP      HL          ; LSBs of base
 3925 196E 222981                  LD       (FPREG),HL  ; Save in FPREG
 3926 1971 DC2E19                  CALL     C,NEGAFT    ; Odd power - Negate re
 3927 1974 CCC316                  CALL     Z,INVSGN    ; Negative base - Negat
 3928 1977 D5                      PUSH     DE          ; Save power
 3929 1978 C5                      PUSH     BC
 3930 1979 CD4E15                  CALL     LOG         ; Get LOG of base
 3931 197C C1                      POP      BC          ; Restore power
 3932 197D D1                      POP      DE
 3933 197E CD8F15                  CALL     FPMULT      ; Multiply LOG by power
 3934                   ;
 3935 1981 CDCB16       EXP:       CALL     STAKFP      ; Put value on stack
 3936 1984 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 3937 1987 113BAA                  LD       DE,0AA3BH
 3938 198A CD8F15                  CALL     FPMULT      ; Multiply value by 1/L
 3939 198D 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 3940 1990 FE88                    CP       80H+8       ; Is it in range?
 3941 1992 D27616                  JP       NC,OVTST1   ; No - Test for overflo
 3942 1995 CD6D17                  CALL     INT         ; Get INT of FPREG
 3943 1998 C680                    ADD      A,80H       ; For excess 128
 3944 199A C602                    ADD      A,2         ; Exponent > 126?
 3945 199C DA7616                  JP       C,OVTST1    ; Yes - Test for overfl
 3946 199F F5                      PUSH     AF          ; Save scaling factor
 3947 19A0 213D15                  LD       HL,UNITY    ; Point to 1.
 3948 19A3 CD4514                  CALL     ADDPHL      ; Add 1 to FPREG
 3949 19A6 CD8615                  CALL     MULLN2      ; Multiply by LN(2)
 3950 19A9 F1                      POP      AF          ; Restore scaling facto
 3951 19AA C1                      POP      BC          ; Restore exponent
 3952 19AB D1                      POP      DE
 3953 19AC F5                      PUSH     AF          ; Save scaling factor
 3954 19AD CD5114                  CALL     SUBCDE      ; Subtract exponent fro
 3955 19B0 CDC316                  CALL     INVSGN      ; Negate result
 3956 19B3 21C119                  LD       HL,EXPTAB   ; Coefficient table
 3957 19B6 CDF119                  CALL     SMSER1      ; Sum the series
 3958 19B9 110000                  LD       DE,0        ; Zero LSBs
 3959 19BC C1                      POP      BC          ; Scaling factor
 3960 19BD 4A                      LD       C,D         ; Zero MSB
 3961 19BE C38F15                  JP       FPMULT      ; Scale result to corre
 3962                   ;
 3963 19C1 08           EXPTAB:    DB       8           ; Table used by EXP
 3964 19C2 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 3965 19C6 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 3966 19CA 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 3967 19CE E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 3968 19D2 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 3969 19D6 FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 3970 19DA 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 3971 19DE 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 3972                   ;
 3973 19E2 CDCB16       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 3974 19E5 118D15                  LD       DE,MULT     ; Multiply by "X"
 3975 19E8 D5                      PUSH     DE          ; To be done after
 3976 19E9 E5                      PUSH     HL          ; Save address of table
 3977 19EA CDE616                  CALL     BCDEFP      ; Move FPREG to BCDE
 3978 19ED CD8F15                  CALL     FPMULT      ; Square the value
 3979 19F0 E1                      POP      HL          ; Restore address of ta
 3980 19F1 CDCB16       SMSER1:    CALL     STAKFP      ; Put value on stack
 3981 19F4 7E                      LD       A,(HL)      ; Get number of coeffic
 3982 19F5 23                      INC      HL          ; Point to start of tab
 3983 19F6 CDD816                  CALL     PHLTFP      ; Move coefficient to F
 3984 19F9 06                      DB       06H         ; Skip "POP AF"
 3985 19FA F1           SUMLP:     POP      AF          ; Restore count
 3986 19FB C1                      POP      BC          ; Restore number
 3987 19FC D1                      POP      DE
 3988 19FD 3D                      DEC      A           ; Cont coefficients
 3989 19FE C8                      RET      Z           ; All done
 3990 19FF D5                      PUSH     DE          ; Save number
 3991 1A00 C5                      PUSH     BC
 3992 1A01 F5                      PUSH     AF          ; Save count
 3993 1A02 E5                      PUSH     HL          ; Save address in table
 3994 1A03 CD8F15                  CALL     FPMULT      ; Multiply FPREG by BCD
 3995 1A06 E1                      POP      HL          ; Restore address in ta
 3996 1A07 CDE916                  CALL     LOADFP      ; Number at HL to BCDE
 3997 1A0A E5                      PUSH     HL          ; Save address in table
 3998 1A0B CD5414                  CALL     FPADD       ; Add coefficient to FP
 3999 1A0E E1                      POP      HL          ; Restore address in ta
 4000 1A0F C3FA19                  JP       SUMLP       ; More coefficients
 4001                   ;
 4002 1A12 CD9A16       RND:       CALL     TSTSGN      ; Test sign of FPREG
 4003 1A15 215E80                  LD       HL,SEED+2   ; Random number seed
 4004 1A18 FA731A                  JP       M,RESEED    ; Negative - Re-seed
 4005 1A1B 217F80                  LD       HL,LSTRND   ; Last random number
 4006 1A1E CDD816                  CALL     PHLTFP      ; Move last RND to FPRE
 4007 1A21 215E80                  LD       HL,SEED+2   ; Random number seed
 4008 1A24 C8                      RET      Z           ; Return if RND(0)
 4009 1A25 86                      ADD      A,(HL)      ; Add (SEED)+2)
 4010 1A26 E607                    AND      00000111B   ; 0 to 7
 4011 1A28 0600                    LD       B,0
 4012 1A2A 77                      LD       (HL),A      ; Re-save seed
 4013 1A2B 23                      INC      HL          ; Move to coefficient t
 4014 1A2C 87                      ADD      A,A         ; 4 bytes
 4015 1A2D 87                      ADD      A,A         ; per entry
 4016 1A2E 4F                      LD       C,A         ; BC = Offset into tabl
 4017 1A2F 09                      ADD      HL,BC       ; Point to coefficient
 4018 1A30 CDE916                  CALL     LOADFP      ; Coefficient to BCDE
 4019 1A33 CD8F15                  CALL     FPMULT      ;       ; Multiply FPRE
 4020 1A36 3A5D80                  LD       A,(SEED+1)  ; Get (SEED+1)
 4021 1A39 3C                      INC      A           ; Add 1
 4022 1A3A E603                    AND      00000011B   ; 0 to 3
 4023 1A3C 0600                    LD       B,0
 4024 1A3E FE01                    CP       1           ; Is it zero?
 4025 1A40 88                      ADC      A,B         ; Yes - Make it 1
 4026 1A41 325D80                  LD       (SEED+1),A  ; Re-save seed
 4027 1A44 21771A                  LD       HL,RNDTAB-4 ; Addition table
 4028 1A47 87                      ADD      A,A         ; 4 bytes
 4029 1A48 87                      ADD      A,A         ; per entry
 4030 1A49 4F                      LD       C,A         ; BC = Offset into tabl
 4031 1A4A 09                      ADD      HL,BC       ; Point to value
 4032 1A4B CD4514                  CALL     ADDPHL      ; Add value to FPREG
 4033 1A4E CDE616       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4034 1A51 7B                      LD       A,E         ; Get LSB
 4035 1A52 59                      LD       E,C         ; LSB = MSB
 4036 1A53 EE4F                    XOR      01001111B   ; Fiddle around
 4037 1A55 4F                      LD       C,A         ; New MSB
 4038 1A56 3680                    LD       (HL),80H    ; Set exponent
 4039 1A58 2B                      DEC      HL          ; Point to MSB
 4040 1A59 46                      LD       B,(HL)      ; Get MSB
 4041 1A5A 3680                    LD       (HL),80H    ; Make value -0.5
 4042 1A5C 215C80                  LD       HL,SEED     ; Random number seed
 4043 1A5F 34                      INC      (HL)        ; Count seed
 4044 1A60 7E                      LD       A,(HL)      ; Get seed
 4045 1A61 D6AB                    SUB      171         ; Do it modulo 171
 4046 1A63 C26A1A                  JP       NZ,RND2     ; Non-zero - Ok
 4047 1A66 77                      LD       (HL),A      ; Zero seed
 4048 1A67 0C                      INC      C           ; Fillde about
 4049 1A68 15                      DEC      D           ; with the
 4050 1A69 1C                      INC      E           ; number
 4051 1A6A CDA514       RND2:      CALL     BNORM       ; Normalise number
 4052 1A6D 217F80                  LD       HL,LSTRND   ; Save random number
 4053 1A70 C3F216                  JP       FPTHL       ; Move FPREG to last an
 4054                   ;
 4055 1A73 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4056 1A74 2B                      DEC      HL
 4057 1A75 77                      LD       (HL),A
 4058 1A76 2B                      DEC      HL
 4059 1A77 77                      LD       (HL),A
 4060 1A78 C34E1A                  JP       RND1        ; Return RND seed
 4061                   ;
 4062 1A7B 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4063 1A7F 99E99269                DB       099H,0E9H,092H,069H
 4064 1A83 10D17568                DB       010H,0D1H,075H,068H
 4065                   ;
 4066 1A87 21D11A       COS:       LD       HL,HALFPI   ; Point to PI/2
 4067 1A8A CD4514                  CALL     ADDPHL      ; Add it to PPREG
 4068 1A8D CDCB16       SIN:       CALL     STAKFP      ; Put angle on stack
 4069 1A90 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4070 1A93 11DB0F                  LD       DE,0FDBH
 4071 1A96 CDDB16                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4072 1A99 C1                      POP      BC          ; Restore angle
 4073 1A9A D1                      POP      DE
 4074 1A9B CDF015                  CALL     DVBCDE      ; Divide angle by 2 PI
 4075 1A9E CDCB16                  CALL     STAKFP      ; Put it on stack
 4076 1AA1 CD6D17                  CALL     INT         ; Get INT of result
 4077 1AA4 C1                      POP      BC          ; Restore number
 4078 1AA5 D1                      POP      DE
 4079 1AA6 CD5114                  CALL     SUBCDE      ; Make it 0 <= value < 
 4080 1AA9 21D51A                  LD       HL,QUARTR   ; Point to 0.25
 4081 1AAC CD4B14                  CALL     SUBPHL      ; Subtract value from 0
 4082 1AAF CD9A16                  CALL     TSTSGN      ; Test sign of value
 4083 1AB2 37                      SCF                  ; Flag positive
 4084 1AB3 F2BD1A                  JP       P,SIN1      ; Positive - Ok
 4085 1AB6 CD4214                  CALL     ROUND       ; Add 0.5 to value
 4086 1AB9 CD9A16                  CALL     TSTSGN      ; Test sign of value
 4087 1ABC B7                      OR       A           ; Flag negative
 4088 1ABD F5           SIN1:      PUSH     AF          ; Save sign
 4089 1ABE F4C316                  CALL     P,INVSGN    ; Negate value if posit
 4090 1AC1 21D51A                  LD       HL,QUARTR   ; Point to 0.25
 4091 1AC4 CD4514                  CALL     ADDPHL      ; Add 0.25 to value
 4092 1AC7 F1                      POP      AF          ; Restore sign
 4093 1AC8 D4C316                  CALL     NC,INVSGN   ; Negative - Make posit
 4094 1ACB 21D91A                  LD       HL,SINTAB   ; Coefficient table
 4095 1ACE C3E219                  JP       SUMSER      ; Evaluate sum of serie
 4096                   ;
 4097 1AD1 DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4098                   ;
 4099 1AD5 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4100                   ;
 4101 1AD9 05           SINTAB:    DB       5           ; Table used by SIN
 4102 1ADA BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4103 1ADE 64269987                DB       064H,026H,099H,087H ;-76.575
 4104 1AE2 58342387                DB       058H,034H,023H,087H ; 81.602
 4105 1AE6 E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4106 1AEA DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4107                   ;
 4108 1AEE CDCB16       TAN:       CALL     STAKFP      ; Put angle on stack
 4109 1AF1 CD8D1A                  CALL     SIN         ; Get SIN of angle
 4110 1AF4 C1                      POP      BC          ; Restore angle
 4111 1AF5 E1                      POP      HL
 4112 1AF6 CDCB16                  CALL     STAKFP      ; Save SIN of angle
 4113 1AF9 EB                      EX       DE,HL       ; BCDE = Angle
 4114 1AFA CDDB16                  CALL     FPBCDE      ; Angle to FPREG
 4115 1AFD CD871A                  CALL     COS         ; Get COS of angle
 4116 1B00 C3EE15                  JP       DIV         ; TAN = SIN / COS
 4117                   ;
 4118 1B03 CD9A16       ATN:       CALL     TSTSGN      ; Test sign of value
 4119 1B06 FC2E19                  CALL     M,NEGAFT    ; Negate result after i
 4120 1B09 FCC316                  CALL     M,INVSGN    ; Negate value if -ve
 4121 1B0C 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4122 1B0F FE81                    CP       81H         ; Number less than 1?
 4123 1B11 DA201B                  JP       C,ATN1      ; Yes - Get arc tangnt
 4124 1B14 010081                  LD       BC,8100H    ; BCDE = 1
 4125 1B17 51                      LD       D,C
 4126 1B18 59                      LD       E,C
 4127 1B19 CDF015                  CALL     DVBCDE      ; Get reciprocal of num
 4128 1B1C 214B14                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4129 1B1F E5                      PUSH     HL          ; Save for angle > 1
 4130 1B20 212A1B       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4131 1B23 CDE219                  CALL     SUMSER      ; Evaluate sum of serie
 4132 1B26 21D11A                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4133 1B29 C9                      RET                  ; Number > 1 - Sub from
 4134                   ;
 4135 1B2A 09           ATNTAB:    DB       9           ; Table used by ATN
 4136 1B2B 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4137 1B2F 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4138 1B33 FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4139 1B37 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4140 1B3B 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4141 1B3F C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4142 1B43 E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4143 1B47 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4144 1B4B 00000081                DB       000H,000H,000H,081H ; 1/1
 4145                   ;
 4146                   
 4147 1B4F C9           ARET:      RET                  ; A RETurn instruction
 4148                   ;
 4149 1B50 D7           GETINP:    RST      10H         ;input a character
 4150 1B51 C9                      RET
 4151                   ;
 4152 1B52              CLS:
 4153 1B52 3E0C                    LD       A,CS        ; ASCII Clear screen
 4154 1B54 C3881C                  JP       MONOUT      ; Output character
 4155                   ;
 4156 1B57 CD1914       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4157 1B5A 7B                      LD       A,E         ; Width to A
 4158 1B5B 328780                  LD       (LWIDTH),A  ; Set width
 4159 1B5E C9                      RET
 4160                   ;
 4161 1B5F CDB80C       LINES:     CALL     GETNUM      ; Get a number
 4162 1B62 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 4163 1B65 ED538B80                LD       (LINESC),DE ; Set lines counter
 4164 1B69 ED538D80                LD       (LINESN),DE ; Set lines number
 4165 1B6D C9                      RET
 4166                   ;
 4167 1B6E CDFD08       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4168 1B71 D5                      PUSH     DE          ; Save number
 4169 1B72 E1                      POP      HL          ; Number to HL
 4170 1B73 46                      LD       B,(HL)      ; Get LSB of contents
 4171 1B74 23                      INC      HL
 4172 1B75 7E                      LD       A,(HL)      ; Get MSB of contents
 4173 1B76 C37310                  JP       ABPASS      ; Return integer AB
 4174                   ;
 4175 1B79 CDB80C       DOKE:      CALL     GETNUM      ; Get a number
 4176 1B7C CDFD08                  CALL     DEINT       ; Get integer -32768 to
 4177 1B7F D5                      PUSH     DE          ; Save address
 4178 1B80 CDC106                  CALL     CHKSYN      ; Make sure ',' follows
 4179 1B83 2C                      DB       ','
 4180 1B84 CDB80C                  CALL     GETNUM      ; Get a number
 4181 1B87 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 4182 1B8A E3                      EX       (SP),HL     ; Save value,get addres
 4183 1B8B 73                      LD       (HL),E      ; Save LSB of value
 4184 1B8C 23                      INC      HL
 4185 1B8D 72                      LD       (HL),D      ; Save MSB of value
 4186 1B8E E1                      POP      HL          ; Restore code string a
 4187 1B8F C9                      RET
 4188                   ;
 4189                   
 4190                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4191                   ;
 4192 1B90 CDBB0C       HEX:       CALL     TSTNUM      ; Verify it's a number
 4193 1B93 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 4194 1B96 C5                      PUSH     BC          ; Save contents of BC
 4195 1B97 212E81                  LD       HL,PBUFF
 4196 1B9A 7A                      LD       A,D         ; Get high order into A
 4197 1B9B FE00                    CP       0
 4198 1B9D 280C                    JR       Z,HEX2      ; Skip output if both h
 4199 1B9F CDC81B                  CALL     BYT2ASC     ; Convert D to ASCII
 4200 1BA2 78                      LD       A,B
 4201 1BA3 FE30                    CP       '0'
 4202 1BA5 2802                    JR       Z,HEX1      ; Don't store high digi
 4203 1BA7 70                      LD       (HL),B      ; Store it to PBUFF
 4204 1BA8 23                      INC      HL          ; Next location
 4205 1BA9 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4206 1BAA 23                      INC      HL          ; Next location
 4207 1BAB 7B           HEX2:      LD       A,E         ; Get lower byte
 4208 1BAC CDC81B                  CALL     BYT2ASC     ; Convert E to ASCII
 4209 1BAF 7A                      LD       A,D
 4210 1BB0 FE00                    CP       0
 4211 1BB2 2005                    JR       NZ,HEX3     ; If upper byte was not
 4212 1BB4 78                      LD       A,B
 4213 1BB5 FE30                    CP       '0'         ; If high digit of lowe
 4214 1BB7 2802                    JR       Z,HEX4
 4215 1BB9 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4216 1BBA 23                      INC      HL          ; Next location
 4217 1BBB 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4218 1BBC 23                      INC      HL          ; PBUFF+4 to zero
 4219 1BBD AF                      XOR      A           ; Terminating character
 4220 1BBE 77                      LD       (HL),A      ; Store zero to termina
 4221 1BBF 23                      INC      HL          ; Make sure PBUFF is te
 4222 1BC0 77                      LD       (HL),A      ; Store the double zero
 4223 1BC1 C1                      POP      BC          ; Get BC back
 4224 1BC2 212E81                  LD       HL,PBUFF    ; Reset to start of PBU
 4225 1BC5 C32111                  JP       STR1        ; Convert the PBUFF to 
 4226                   ;
 4227 1BC8 47           BYT2ASC    LD       B,A         ; Save original value
 4228 1BC9 E60F                    AND      0FH         ; Strip off upper nybbl
 4229 1BCB FE0A                    CP       0AH         ; 0-9?
 4230 1BCD 3802                    JR       C,ADD30     ; If A-F, add 7 more
 4231 1BCF C607                    ADD      A,07H       ; Bring value up to ASC
 4232 1BD1 C630         ADD30      ADD      A,30H       ; And make ASCII
 4233 1BD3 4F                      LD       C,A         ; Save converted char t
 4234 1BD4 78                      LD       A,B         ; Retrieve original val
 4235 1BD5 0F                      RRCA                 ; and Rotate it right
 4236 1BD6 0F                      RRCA
 4237 1BD7 0F                      RRCA
 4238 1BD8 0F                      RRCA
 4239 1BD9 E60F                    AND      0FH         ; Mask off upper nybble
 4240 1BDB FE0A                    CP       0AH         ; 0-9? < A hex?
 4241 1BDD 3802                    JR       C,ADD301    ; Skip Add 7
 4242 1BDF C607                    ADD      A,07H       ; Bring it up to ASCII 
 4243 1BE1 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4244 1BE3 47                      LD       B,A         ; Store high order byte
 4245 1BE4 C9                      RET
 4246                   ;
 4247                   ; Convert "&Hnnnn" to FPREG
 4248                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4249                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4250 1BE5 EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4251 1BE6 210000                  LD       HL,0000H    ; Zero out the value
 4252 1BE9 CDFE1B                  CALL     GETHEX      ; Check the number for 
 4253 1BEC DA1E1C                  JP       C,HXERR     ; First value wasn't he
 4254 1BEF 1805                    JR       HEXLP1      ; Convert first charact
 4255 1BF1 CDFE1B       HEXLP      CALL     GETHEX      ; Get second and addtio
 4256 1BF4 381F                    JR       C,HEXIT     ; Exit if not a hex cha
 4257 1BF6 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4258 1BF7 29                      ADD      HL,HL
 4259 1BF8 29                      ADD      HL,HL
 4260 1BF9 29                      ADD      HL,HL
 4261 1BFA B5                      OR       L           ; Add in D0-D3 into L
 4262 1BFB 6F                      LD       L,A         ; Save new value
 4263 1BFC 18F3                    JR       HEXLP       ; And continue until al
 4264                   ;
 4265 1BFE 13           GETHEX     INC      DE          ; Next location
 4266 1BFF 1A                      LD       A,(DE)      ; Load character at poi
 4267 1C00 FE20                    CP       ' '
 4268 1C02 CAFE1B                  JP       Z,GETHEX    ; Skip spaces
 4269 1C05 D630                    SUB      30H         ; Get absolute value
 4270 1C07 D8                      RET      C           ; < "0", error
 4271 1C08 FE0A                    CP       0AH
 4272 1C0A 3805                    JR       C,NOSUB7    ; Is already in the ran
 4273 1C0C D607                    SUB      07H         ; Reduce to A-F
 4274 1C0E FE0A                    CP       0AH         ; Value should be $0A-$
 4275 1C10 D8                      RET      C           ; CY set if was :      
 4276 1C11 FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4277 1C13 3F                      CCF
 4278 1C14 C9                      RET                  ; CY set if it wasn't v
 4279                   
 4280 1C15 EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4281 1C16 7A                      LD       A,D         ; Load DE into AC
 4282 1C17 4B                      LD       C,E         ; For prep to
 4283 1C18 E5                      PUSH     HL
 4284 1C19 CD7210                  CALL     ACPASS      ; ACPASS to set AC as i
 4285 1C1C E1                      POP      HL
 4286 1C1D C9                      RET
 4287                   ;
 4288 1C1E 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4289 1C20 C30704                  JP       ERROR
 4290                   ;
 4291                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4292 1C23 CDBB0C       BIN:       CALL     TSTNUM      ; Verify it's a number
 4293 1C26 CDFD08                  CALL     DEINT       ; Get integer -32768 to
 4294 1C29 C5           BIN2:      PUSH     BC          ; Save contents of BC
 4295 1C2A 212E81                  LD       HL,PBUFF
 4296 1C2D 0611                    LD       B,17        ; One higher than max c
 4297 1C2F              ZEROSUP:                        ; Suppress leading zero
 4298 1C2F 05                      DEC      B           ; Max 16 chars
 4299 1C30 78                      LD       A,B
 4300 1C31 FE01                    CP       01H
 4301 1C33 2808                    JR       Z,BITOUT    ; Always output at leas
 4302 1C35 CB13                    RL       E
 4303 1C37 CB12                    RL       D
 4304 1C39 30F4                    JR       NC,ZEROSUP
 4305 1C3B 1804                    JR       BITOUT2
 4306 1C3D              BITOUT:
 4307 1C3D CB13                    RL       E
 4308 1C3F CB12                    RL       D           ; Top bit now in carry
 4309 1C41              BITOUT2:
 4310 1C41 3E30                    LD       A,'0'       ; Char for '0'
 4311 1C43 CE00                    ADC      A,0         ; If carry set then '0'
 4312 1C45 77                      LD       (HL),A
 4313 1C46 23                      INC      HL
 4314 1C47 05                      DEC      B
 4315 1C48 20F3                    JR       NZ,BITOUT
 4316 1C4A AF                      XOR      A           ; Terminating character
 4317 1C4B 77                      LD       (HL),A      ; Store zero to termina
 4318 1C4C 23                      INC      HL          ; Make sure PBUFF is te
 4319 1C4D 77                      LD       (HL),A      ; Store the double zero
 4320 1C4E C1                      POP      BC
 4321 1C4F 212E81                  LD       HL,PBUFF
 4322 1C52 C32111                  JP       STR1
 4323                   ;
 4324                   ; Convert "&Bnnnn" to FPREG
 4325                   ; Gets a character from (HL) checks for Binary ASCII nu
 4326 1C55 EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4327 1C56 210000                  LD       HL,0000H    ; Zero out the value
 4328 1C59 CD721C                  CALL     CHKBIN      ; Check the number for 
 4329 1C5C DA801C                  JP       C,BINERR    ; First value wasn't bi
 4330 1C5F D630         BINIT:     SUB      '0'
 4331 1C61 29                      ADD      HL,HL       ; Rotate HL left
 4332 1C62 B5                      OR       L
 4333 1C63 6F                      LD       L,A
 4334 1C64 CD721C                  CALL     CHKBIN      ; Get second and addtio
 4335 1C67 30F6                    JR       NC,BINIT    ; Process if a bin char
 4336 1C69 EB                      EX       DE,HL       ; Value into DE, Code s
 4337 1C6A 7A                      LD       A,D         ; Load DE into AC
 4338 1C6B 4B                      LD       C,E         ; For prep to
 4339 1C6C E5                      PUSH     HL
 4340 1C6D CD7210                  CALL     ACPASS      ; ACPASS to set AC as i
 4341 1C70 E1                      POP      HL
 4342 1C71 C9                      RET
 4343                   ;
 4344                   ; Char is in A, NC if char is 0 or 1
 4345 1C72 13           CHKBIN:    INC      DE
 4346 1C73 1A                      LD       A,(DE)
 4347 1C74 FE20                    CP       ' '
 4348 1C76 CA721C                  JP       Z,CHKBIN    ; Skip spaces
 4349 1C79 FE30                    CP       '0'         ; Set C if < '0'
 4350 1C7B D8                      RET      C
 4351 1C7C FE32                    CP       '2'
 4352 1C7E 3F                      CCF                  ; Set C if > '1'
 4353 1C7F C9                      RET
 4354                   ;
 4355 1C80 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4356 1C82 C30704                  JP       ERROR
 4357                   ;
 4358 1C85 C34C00       JJUMP1:    JP       CSTART      ; Go and initialise
 4359                   ;
 4360 1C88 C30800       MONOUT:    JP       0008H       ; output a char
 4361                   ;
 4362 1C8B C30000       MONITR:    JP       0000H       ; Restart (Normally Mon
 4363                   ;
 4364 1C8E 3E00         INITST:    LD       A,0         ; Clear break flag
 4365 1C90 329280                  LD       (BRKFLG),A
 4366 1C93 C35300                  JP       INIT
 4367                   ;
 4368 1C96 F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4369 1C97 A0                      AND      B           ; Get common bits
 4370 1C98 C1                      POP      BC          ; Restore bit mask
 4371 1C99 B8                      CP       B           ; Same bit set?
 4372 1C9A 3E00                    LD       A,0         ; Return 0 in A
 4373 1C9C C9                      RET
 4374                   ;
 4375 1C9D CDCC06       OUTNCR:    CALL     OUTC        ; Output character in A
 4376 1CA0 C3F30A                  JP       PRCRLF      ; Output CRLF
 4377                   ;
 4378 1CA3                         END
